# 简介

类图在UML 的静态机制中是重要的组成部分，它不但是设计人员关心的核心，更是实现人员关注的重点。建模工具也主要根据类图来产生代码。类图在UML 的9个图中占据了一个相当重要的地位。

类图是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型，它用于描述系统的结构。类图的建模贯穿系统的分析和设计阶段的始终，通常从用户能够理解的用例开始建模，最终到系统开发小组能够完全理解的类。



## 概述

类是对一组具有相同属性、操作、关系和语义的对象的抽象。主要包括名称部分（Name）、属性部分（Attribute）和操作部分（Operation）。在UML中类用一个矩形框表示，它包含三个区域，最上面是类名、中间是类的属性、最下面是类的方法。 

![](https://img1.zlogs.net/20/20200117211156.png)

### （1）名称

每个类都必须有一个能和其它类进行区分的名称，类的名称部分是不能省略的，其它组成部分可以省略。名称（Name）是一个文本串，类的命名要求由字符、数字、下划线组成的惟一的字符串即可。 

### （2）属性

属性描述了类在软件系统中代表的事物（即对象）所具备的特性。类可以有任意数目的属性，也可以没有属性。类如果有属性，则每一个属性都必须有一个名字，另外还可以有其它的描述信息，如可见性、数据类型、缺省值等。 

在UML中，类属性的语法为：

`[可见性] 属性名 [:类型][=初始值] [{属性字符串}]`

#### ①可见性

类中属性的可见性主要包括公有（public）、私有（Private）和受保护（Protected）。

在UML中，**用“+”表达公有类型，用“-”表达私有类型，而用“#”表达受保护类型**。UML的类中不存在默认的可见性，如果没有显示任何一种符号，就表示没有定义该属性的可见性。（java默认可见性可以用~表示）

#### ②属性名

每个属性都必须有一个名字以区别于类中的其他属性，是类的一个特性。

属性名由描述所属类的特性的名词或名词短语组成。按照UML的约定，**单字属性名小写**。如果属性名包含多个单词，这些单词要合并，且**除了第一个单词外其余单词的首字母要大写**。

#### ③类型

说明属性的数据类型。

在类的图标里，可以指定每个属性值的类型。可能的类型包括字符串（string）、浮点型（float）、整型（int）和布尔型（boolean）（以及其他的枚举类型）。指明类型时，需要在属性值后面加上类型名，中间用冒号隔开。还可以为属性指定一个缺省值。

#### ④初始值

为了保护系统的完整性，防止漏掉取值或被非法的值破坏系统的完整性，可以设定属性的初始值。

#### ⑤属性字符串

属性字符串用来指定关于属性的其他信息，例如某个属性应该是永久的。

任何希望添加在属性定义字符串值但又没有合适地方可以加入的规则，都可以放在属性字符串里。

### （3）操作

操作是对类的对象所能做的事务的一个抽象。一个类可以有任意数量的操作或者根本没有操作。类如果有操作，则每一个操作也都有一个名字，其它可选的信息包括可见性、参数的名字、参数类型、参数缺省值和操作的返回值的类型等。 

在UML中，类操作的语法为：`[可见性] 操作名 [（参数表）][:返回类型] [{属性字符串}]`

### （4）职责

在操作列表框下面的区域，你可以用来说明类的职责。职责位于操作部分下面的区域，可以用来说明类要做什么或说明另一个类的信息。类的职责可以是一个短语或一个句子。在UML中，把职责列在类图底部的分隔栏中 

### （5）约束

说明类的职责是消除二义性的一种非形式化的方法，形式化的方法是使用约束。约束指定了该类所要满足的一个或多个规则。在UML中，约束是用{}的格式写在类的边上，指定个别属性的取值范围。



--------------------



在图书管理系统中的借阅者类，类名为借阅者，共有5个属性：借阅证号、是否有借阅资源、姓名、性别和类别；操作有借书和还书。如图5.3所示。在图5.3中，借阅者是类的名称，5个属性中，借阅证号、是否有借阅资源是私有属性（private），类型分别为int和boolean。姓名、性别和类别属性是公有属性，类型都是string。2个操作都是公有的（public），均没有返回值。

![](https://img1.zlogs.net/20/20200117211157.png)

```c++
//用C++实现的程序如下：
class Account
{
public:
   virtual double Deposite（double Amount）;
   virtual double ComputInterest（）;
private:
   double balance=1;
};
```





## 接口

接口（interface）：是描述类的部分行为的一组操作，它也是一个类提供给另一个类的一组操作。通常接口被描述为抽象操作，也就是只用标识（返回值、操作名称、参数表）说明它的行为，而真正实现部分放在使用该接口的对象中，也就是说接口只负责定义操作而不具体的实现。 



## 抽象类

抽象类是包含一种或多种抽象方法的类，它本身不需要构造实例。定义抽象类后，其它类可以对它进行扩充并且通过实现其中的抽象方法，使抽象类具体化。在UML中抽象类的图形表示和类图一样，只是在最上面一层的类名前加描述`<<abstract>>`或是在类的属性描述上设置该类为抽象类，抽象类的类名是斜体表示。



## 类之间的关系

关系是指事物之间的联系。在面向对象的建模中，类之间最常见的关系有：依赖关系、泛化关系、关联关系和实现关系。在图形上，把关系画成一条线，并用不同的线来区别关系的种类。



### 依赖关系

依赖关系（Dependency）表示两个或多个模型元素之间语义上的关系。它表示了这样一种情形，对于一个元素（服务提供者）的某些改变可能会影响或提供消息给其他元素（使用者），即使用者以某种形式依赖于其他类元。在UML图形上，把依赖画成一条有向的虚线，指向被依赖的事物。当要指明一个事物使用另一个事物时，就使用依赖。

![](https://img1.zlogs.net/20/20200117211158.png)

（1）使用依赖

（2）抽象依赖 

（3）授权依赖

（4）绑定依赖



------------

在下图中模板类`Stack<T>`定义了栈相关的操作；IntStack将参数T与实际类型int绑定，使得所有操作都针对int类型的数据。

![](https://img1.zlogs.net/20/20200117211159.png)



```c++
//表示的bind依赖关系，使用C++生成的程序如下：
template<typename T>
class Stack
{ 
private:
  int size;
public:
  int Push（T elem）;
  int Pop（）;
  const T& GetTop（）;
};
typedef Stack<float> FloatStack;

```



### 泛化关系

泛化关系（Generalization）是一种存在于一般元素和特殊元素之间的分类关系，它只使用在类型上，而不是实例上。在类中，一般元素被称为超类或父类，而特殊元素被称为子类。在UML中，泛化关系用一条从子类指向父类的空心三角箭头表示

![](https://img1.zlogs.net/20/20200117211200.png)



--------------



在下图中Account类是抽象类，SavingsAccount类是子类，继承父类的方法

![](https://img1.zlogs.net/20/20200117211201.png)



```c++
//表示的泛化关系，使用C++生成的程序如下：
class SavingsAccount : public Account
{ };
```



### 关联关系

关联关系（Association）是一种结构关系，它指明一个事物的对象与另一个事物的对象之间的联系。也就是说，关联描述了系统中对象或实例之间的离散连接。给定一个连接两个类的关联，可以从一个类的对象联系到另一个类的对象。关联的两端都连接到一个类在理论上也是合法的。在UML图形中，关联关系用一条连接两个类的实线表示。

![](https://img1.zlogs.net/20/20200117211202.png)

```c++
//表示的关联关系，使用C++生成的程序如下：
// 类Library 的源码
public class Library
{
    public Book  theBook;
    public Library （） { }
}
// 类Book的源码
public class Book
{
    public Library  theLibrary;
    public Book （） { }
}

```





在UML中，有4种可应用到关联的基本修饰：关联名、关联端的角色、关联端的多重性和聚合。

（1）关联名即名称（Name）（2）角色（Role）（3）多重性（Multiplicity）（4）聚合（Aggregation）（5）组合关系（Composition）（6）导航性（Nevigation）（7）关联类（8）约束



### 实现关系

实现将一种模型元素与另一种模型元素连接起来，比如类和接口。泛化和实现关系都可以将一般描述与具体描述联系起来。泛化将同一语义层上的元素连接起来，并且通常在同一模型内。实现关系则将不同语义层内的元素连接起来，通常建立在不同的模型内。

实现关系通常在两种情况下被使用：在接口与实现该接口的类之间；在用例以及实现该用例的协作之间。





































