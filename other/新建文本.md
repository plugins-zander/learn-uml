# 1 软件建模概述

## 1.1 软件建模的概念

- 模型是对现实存在的实体进行抽象和简化，模型提供了系统的蓝图。模型过虑了非本质的细节信息，使问题更容易理解。
- 为建立复杂的软件系统，我们必须抽象出系统的不同视图，使用精确的符号建立模型，验证这些模型是否满足系统的需求，并逐渐添加细节信息把这些模型转变为实现。这就是软件建模。这样的一个过程就是软件模型形成的过程，软件建模是捕捉系统本质的过程，把问题领域转移到解决领域的过程。

```
什么是建模
建模是一项经过检验并被广为接受的工程技术。建立房屋和大厦的建筑模型，能帮助用户得到实际建筑物的印象，甚至可以建立数学模型来分析大风或地震对建筑物造成的影响。
建模不只适用于建筑业。如果不首先构造模型（从计算机模型到物理风洞模型，再到与实物大小一样的原型），就装配新型的飞机或汽车，那简直是难以想象的。新型的电气设备（从微处理器到电话交换系统）需要一定程度的建模，以便更好地理解系统并与他人交流思想。在电影业，情节串联板是产品的核心，这也是建模的一种形式。在社会学、经济学和商业管理领域也需要建模，以证实人们的理论或用最小限度的风险和代价试验新的理论。
那么，模型是什么？简单地说：
模型是对现实的简化。
模型提供了系统的蓝图。模型既可以包括详细的计划，也可以包括从很高的层次考虑系统的总体计划。一个好的模型包括那些有广泛影响的主要元素，而忽略那些与给定的抽象水平不相关的次要元素。每个系统都可以从不同的方面用不同的模型来描述，因而每个模型都是一个在语义上闭合的系统抽象。模型可以是结构性的，强调系统的组织。它也可以是行为性的，强调系统的动态方面。
为什么要建模？一个基本理由是：
建模是为了能够更好地理解正在开发的系统。
通过建模，要达到以下4个目的。
（1）模型有助于按照实际情况或按照所需要的样式对系统进行可视化。
（2）模型能够规约系统的结构或行为。
（3）模型给出了指导构造系统的模板。
（4）模型对做出的决策进行文档化。
```

  

## 1.2 软件建模的用途

- 软件模型就是对复杂问题进行分层，从而更好地解决问题。
- 有效的软件模型有利于分工与专业化生产，从而节省生产成本。
- 对于软件人员来说，模型就好像是工程人员的图纸一样重要。

```
为什么要建模
成功的软件组织应该总是能够交付满足其用户需要的软件。如果一个软件组织能够及时并可预测地开发出这样的软件，并能够有效地利用人力和物力资源，那么这个软件组织就是可持续发展的。
在上段话里有一个重要的含义：一个开发队伍的主要产品不应该是一堆漂亮的文档、世界级的会议、伟大的口号或者几行获得普利策奖金的源代码，而应该是满足不断发展的用户及其业务需要的优秀软件。其他的一切事情都是次要的。
不幸的是，很多软件组织把“次要的”和“不重要的”的含义搞混了。为了得到满足预期功能的软件，必须到用户中去，以一种训练有素的方式访问用户，去揭示系统的真实需求。为了开发出具有持久质量的软件，必须打好能适应变化的、坚实的体系结构基础。为了能快速、有效地开发软件，尽量减少软件废品和重复工作，必须有合适的人员和合适的工具以及合适的工作重点。为了能一贯地、可预测地做到这些，并使得在整个系统的生命期内花费合理，必须有一个能适应业务和技术变化的合理的开发过程。
建模是开发优秀软件的所有活动中的核心部分，其目的是为了把想要得到的系统结构和行为沟通起来，为了对系统的体系结构进行可视化和控制，为了更好地理解正在构造的系统，并经常揭示简化和复用的机会，同时也是为了管理风险。
```



## 1.3 软件建模的优点

- 使用模型便于从整体上、宏观上把握问题，以便更好的解决问题。
- 软件建模可以加强软件工作人员之间的沟通。便于提早发现问题。
- 模型为代码生成提供依据，帮助我们按照实际情况对系统进行可视化。
- 模型允许我们详细说明系统的结构或行为。给出了一个指导我们构造系统的模板。并对我们做出的决策进行文档化。

```
建模的重要性
如果想搭一个狗窝，备好木料、钉子和一些基本工具（如锤子、锯和卷尺）之后，就可以开始工作了。从制订一点初步计划到完成一个满足适当功能的狗窝，可能不用别人帮助，在几个小时内就能够实现。只要狗窝够大且不太漏水，狗就可以安居。如果未能达到希望的效果，返工总是可以的，无非是让狗受点委屈。
如果想为家庭建造一所房子，备好木料、钉子和一些基本工具之后，也能开始工作，但这将需要较长的时间，并且家庭对于房子的需求肯定比狗对于狗窝的需求要多。在这种情况下，除非曾经多次建造过房子，否则就需要事先制定出一些详细的计划，再开始动工，才能够成功。至少应该绘制一些表明房子是什么样子的简图。如果想建造一所能满足家庭的需要并符合当地建筑规范的合格房屋，就需要画一些建筑图，以便能想清楚房间的使用目的以及照明、取暖和水管装置的实际细节问题。做出这些计划后，就能对这项工作所需的时间和物料做出合理的估计。尽管自己也可能建造出这样的房屋，但若有其他人协作，并将工程中的许多关键部分转包出去或购买预制的材料，效率就会高得多。只要按计划行事，不超出时间和财务的预算，家庭多半会对这新房感到满意。如果不制定计划，新房就不会完全令人满意。因此，最好在早期就制定计划，并谨慎地处理好所发生的变化。
如果你要建造一座高层办公大厦，若还是先备好木料、钉子和一些基本工具就开始工作，那将是非常愚蠢的。因为你所使用的资金可能是别人的，他们会对建筑物的规模、形状和风格做出要求。同时，他们经常会改变想法，甚至是在工程已经开工之后。由于失败的代价太高了，因此必须要做详尽的计划。负责建筑物设计和施工的是一个庞大的组织机构，你只是其中的一部分。这个组织将需要各种各样的设计图和模型，以供各方相互沟通。只要得到了合适的人员和工具，并对把建筑概念转换为实际建筑的过程进行积极的管理，将会建成这座满足使用要求的大厦。如果想继续从事建筑工作，那么一定要在使用要求和实际的建筑技术之间做好平衡，并且处理好建筑团队成员们的休息问题，既不能把他们置于风险之中，也不能驱使他们过分辛苦地工作以至于精疲力尽。
奇怪的是，很多软件开发组织开始想建造一座大厦式的软件，而在动手处理时却好像他们正在仓促地造一个狗窝。
有时你是幸运的。如果在恰当的时间有足够的合适人员，并且其他一切事情都很如意，你的团队有可能（仅是可能）推出一个令用户眼花缭乱的软件产品。然而，一般的情况下，不可能所有人员都合适（合适的人员经常供不应求），时间并不总是恰当的（昨天总是更好），其他的事情也并不尽如人意（常常由不得自己）。现在对软件开发的要求正在日益增加，而开发团队却还是经常单纯地依靠他们唯一真正知道如何做好的一件事——编写程序代码。英雄式的编程工作成为这一行业的传奇，人们似乎经常认为更努力地工作是面对开发中出现的各种危机的正常反应。然而，这未必能产生正确的程序代码，而且一些项目是非常巨大的，无论怎样延长工作时间，也不足以完成所需的工作。
如果真正想建造一个相当于房子或大厦类的软件系统，问题可不是仅仅编写许多软件。事实上，关键是要编出正确的软件，并考虑如何少写软件。要生产合格的软件就要有一套关于体系结构、过程和工具的规范。即使如此，很多项目开始看起来像狗窝，但随后发展得像大厦，原因很简单，它们是自己成就的牺牲品。如果对体系结构、过程或工具的规范没有作任何考虑，总有一天狗窝会膨胀成大厦，并会由于其自身的重量而倒塌。狗窝的倒塌可能使你的狗恼怒；同理，不成功的大厦则将对大厦的租户造成严重的影响。
不成功的软件项目失败的原因各不相同，而所有成功的项目在很多方面都是相似的。成功的软件组织有很多成功的因素，其中共同的一点就是对建模的采用。
```



## 1.4 建模原理

```
各种工程学科都有其丰富的建模运用历史。这些经验形成了建模的四项基本原理，现分别叙述如下。

第一，选择要创建什么模型，对如何动手解决问题和如何形成解决方案有着意义深远的影响 。

换句话说，就是要好好地选择模型。正确的模型将清楚地表明最棘手的开发问题，提供不能轻易地从别处获得的洞察力；错误的模型将使人误入歧途，把精力花在不相关的问题上。
暂时先把软件问题放在一边，假设现在正试图解决量子物理学上的一个问题。诸如光子在时空中的相互作用问题，其中充满了令人惊奇的难解的数学问题。选择一个不同的模型，所有的复杂问题一下子就变得可行了（虽然不容易解决）。在这个领域中，这恰恰是费曼图的价值，它提供了对非常复杂问题的图形表示。类似地，在一个完全不同的领域里，假设正在建造一座新建筑，将会关心疾风对它的影响。如果建立了一个物理模型，并拿到风洞中去实验，虽然小模型没有精确地反映出大的实物，但也可以从中找出一些有趣的东西。因此，如果正在建立一个数学模型，然后去模拟，将知道一些不同的东西；与使用物理模型相比，也可能获得更多新的场景。通过对模型进行严格的持续的实验，将更信任已经建模的系统，事实上，它在现实世界中将像期望的那样工作得很好。

对于软件而言，所选择的模型将在很大程度上影响对领域的看法。如果以数据库开发者的观点建造一个系统，可能会注意实体——联系模型，该模型把行为放入触发器和存储过程中。如果以结构化开发者的观点建造一个系统，可能得到以算法为中心的模型，其中包含从处理到处理的数据流。如果以面向对象开发者的观点建造一个系统，将可能得到这样一个系统：它的体系结构以一组类和交互模式（指出这些类如何一起工作）为中心。可执行的模型对测试有很大帮助。上述的任何一种方法对于给定的应用系统和开发文化都可能是正确的，然而经验表明，在构建有弹性的体系结构中面向对象的方法表现得更为出众，即使对使用大型数据库或计算单元的系统也是如此。尽管如此，但要强调一点，不同的方法将导致不同种类的系统，并且代价和收益也是不同的。

第二，可以在不同的精度级别上表示每一种模型 。

如果正在建造一座大厦，有时需要从宏观上让投资者看到大厦的样子，感觉到大厦的总体效果。而有时又需要认真考虑细节问题，例如，对复杂棘手的管道的铺设，或对罕见的结构件的安装等。
对于软件模型也是如此。有时一个快速简洁且是可执行的用户界面模型正是所需要的，而有时必须耐着性子对付比特，例如，描述跨系统接口或解决网络瓶颈问题就是如此。在任何情况下，最好的模型应该是这样的：它可以让你根据谁在进行观察以及为什么要观察选择它的详细程度。分析人员或最终用户主要考虑“做什么”的问题，开发人员主要考虑“怎样做”的问题。这些人员都要在不同的时间以不同的详细程度对系统进行可视化。

第三，最好的模型是与现实相联系的 。

如果一个建筑物的物理模型不能反映真实的建筑物，则它的价值是很有限的；飞机的数学模型，如果只是假定了理想条件和完美制造，则可能掩盖真实飞机的一些潜在的、致命的现实特征。最好是拥有能够清晰地联系实际的模型，而当联系很薄弱时能够精确地知道这些模型如何与现实脱节。所有的模型都对现实进行了简化；诀窍是，确保这种简化不要掩盖掉任何重要的细节。
软件领域中结构化分析的致命弱点是在分析模型和系统设计模型之间没有基本的联系。随着时间的推移，这个不可填充的裂缝会使系统构思阶段和实施阶段出现不一致。在面向对象的系统中，可以把各个几乎独立的系统视图连结成一个完整的语义整体。

第四，单个模型或视图是不充分的。对每个重要的系统最好用一小组几乎独立的模型从多个视角去逼近 。

如果正在建造一所建筑物，会发现没有任何一套单项设计图能够描述该建筑的所有细节。至少需要楼层平面图、立面图、电气设计图、采暖设计图和管道设计图。并且，在任何种类的模型中都需要从多视角来把握系统的范围（例如不同楼层的蓝图）。
在这里的重要短语是“几乎独立的”。在这个语境中，它意味着各种模型能够被分别进行研究和构造，但它们仍然是相互联系的。如同建造建筑物一样，既能够单独地研究电气设计图，但也能看到它如何映射到楼层平面图中，以及它与管道设计图中的管子排布的相互影响。
面向对象的软件系统也如此。为了理解系统的体系结构，需要几个互补和连锁的视图：用况视图（揭示系统的需求）、设计视图（捕获问题空间和解空间里的词汇）、交互视图（展示系统各部分之间以及系统与环境之间的联系）、实现视图（描述系统的物理实现）和部署视图（着眼于系统的工程问题）。每一种视图都可能有结构方面和行为方面。这些视图一起从整体上描绘了软件蓝图。

根据系统的性质，一些模型可能比另一些模型要重要。例如，对于数据密集型系统，表达静态设计视图的模型将占主导地位；对于图形用户界面密集型系统，静态和动态的用况视图就显得相当重要；在硬实时系统中，动态进程视图尤为重要；最后，在分布式系统中，例如 Web 密集型的应用，实现模型和部署模型是最重要的。

```



## 1.5 面向对象建模

```
土木工程师构造了很多种模型。通常这些模型能帮助人们可视化并说明系统的各部分以及这些部分之间的相互关系。根据业务或工程中所着重关心的内容（例如为了帮助研究一个结构在地震时的反应）工程师也可以建立动态模型。各种模型的组织是不同的，各有自己的侧重点。对于软件，有好几种建模的方法。最普通的两种方法是从算法的角度建模和从面向对象的角度建模。

传统的软件开发是从算法的角度进行建模。按照这种方法，所有的软件都用过程或函数作为其主要构造块。这种观点导致开发人员把精力集中于控制流程和对大的算法进行分解。这种观点除了常常产生脆弱的系统之外没有其他本质上的害处。当需求发生变化（总会变化的）以及系统增长（总会增长的）时，用这种方法建造的系统就会变得很难维护。

现代的软件开发采用面向对象的观点进行建模。按照这种方法，所有软件系统都用对象或类作为其主要构造块。简单地讲，对象通常是从问题空间或解空间的词汇中抽取出来的东西；类是对具有共同性质的一组对象（从建模者的视角）的描述。每一个对象都有标识（能够对它命名，以区别于其他对象）、状态（通常有一些数据与它相联系）和行为（能对该对象做某些事，它也能为其他对象做某些事）。

例如，可考虑把一个简单的计账系统的体系结构分成3层：用户界面层、业务服务层和数据库层。在用户界面层，将找出一些具体的对象，如按钮、菜单和对话框。在数据库层，将找出一些具体的对象，例如描述来自问题域实体的表，包括顾客、产品和订单等。在中间层，将找出诸如交易、业务规则等对象，以及顾客、产品和订单等问题实体的高层视图。
可以肯定地说，面向对象方法是软件开发方法的主流部分，其原因很简单，因为事实已经证明，它适合于在各种问题域中建造各种规模和复杂度的系统。此外，当前的大多数程序语言、操作系统和工具在一定程度上都是面向对象的，并给出更多按对象来观察世界的理由。面向对象的开发为使用构件技术（如J2EE或.NET）装配系统提供了概念基础。
选择以面向对象的方式观察世界，会产生一系列的问题：什么是好的面向对象的体系结构？项目会创造出什么样的制品？谁创造它们？怎样度量它们？

对面向对象系统进行可视化、详述、构造和文档化正是统一建模语言（UML）的目的。
```

# 2 UML简介

## 2.1 是什么

UML（Unified Modeling Language统一建模语言），是一种能够描述问题、描述解决方案、起到沟通作用的语言。通俗的说，它是一种用文本、图形和符号的集合来描述现实生活中各类事物、活动、及其之间关系的语言。

统一建模语言（Unified Modeling Language，UML）是一种用于对软件密集型系统的制品进行可视化、详述、构造和文档化的图形语言。UML 给出了一种描绘系统蓝图的标准方法，其中既包括概念性的事物（如业务过程和系统功能），也包括具体的事物（如用特定的编程语言编写的类、数据库模式和可复用的软件构件）。

```
统一建模语言（Unified Modeling Language，UML）是一种绘制软件蓝图的标准语言。可以用UML对软件密集型系统的制品进行可视化、详述、构造和文档化。

从企业信息系统到基于Web的分布式应用，乃至硬实时嵌入式系统，都适合用UML来建模。UML是一种富有表达力的语言，可以描述开发所需要的各种视图，然后以此为基础来部署系统。虽然 UML 的表达力很丰富，但理解和使用它并不困难。要学习使用 UML，一个有效的出发点是形成该语言的概念模型，这要求学习3个要素：UML的基本构造块、支配这些构造块如何放置在一起的规则以及运用于整个语言的一些公共机制。

UML仅仅是一种语言，因此仅仅是软件开发方法的一部分。UML是独立于过程的，但最好把它用于以用况为驱动、以体系结构为中心、迭代和增量的过程。

UML是一种对软件密集型系统的制品进行下述工作的语言：
可视化；
详述；
构造；
文档化。
```



## 2.2 谁使用

进行软件开发、部署和维护的人员均可使用 UML。主要针对用 UML 进行建模的开发组成员，但它也适用于为了理解、建造、测试和发布一个软件密集型系统而一起工作的人员，因为他们要阅读这些模型。虽然这几乎包含了软件开发组织中的所有角色，分析员和最终客户（他们要详细说明系统应该具有的结构和行为）、体系结构设计人员（他们设计满足上述需求的系统）、开发人员（他们把体系结构转换为可执行的代码）、质量保证人员（他们检验并确认系统的结构和行为）、库管理人员（他们创建构件并对构件进行编目）、项目及程序管理者（他们一般是把握方向的领导者，要进行有序的管理，并合理地分配资源，以保证系统的成功交付）。



```
何处使用
UML主要用于软件密集型系统。在下列领域中已经有效地应用了UML：
企业信息系统；
银行与金融服务；
电信；
运输；
国防/航天；
零售；
医疗电子；
科学；
基于Web的分布式服务。
UML 不限于对软件建模。事实上，它的表达能力对非软件系统建模也是足够的。例如，法律系统的工作流程、病人保健系统的结构和行为、飞机战斗系统中的软件工程以及硬件设计等。
```



## 2.3 由什么组成

为了理解UML，需要形成该语言的概念模型，这要求学习建模的3个要素：UML的基本构造块、支配这些构造块如何放在一起的规则和一些运用于整个UML的公共机制。如果掌握了这些思想，就能够读懂UML模型，并能建立一些基本模型。当有了较丰富的应用UML的经验时，就能够在这些概念模型之上使用更高深的语言特征进行构造。

##  2.4发展

```
- 1994年10月，Grady Booch和Jim Rumbaugh于1995年10月发布第一个公开版本，称为统一方法UM 0.8。
- 1995年秋，Booch、Rumbaugh和Jacobson在1996年6月和10月分别发布了两个新的版本，UML 0.9和UML0.91，并将UM重新命名为UML（Unified Modeling Language）。
- 1996年，UML的开发者倡议成立了UML成员协会，以完善、加强和促进UML的定义工作。
- 1996年底，UML已稳占面向对象技术市场的85%，成为可视化建模语言事实上的工业标准。
- 1997年11月17日，OMG采纳UML 1.1作为基于面向对象技术的标准建模语言。
- 几年来，UML一直由OMG的修订任务组（Revision Task Force，RTF）维护，陆续研发了UML的1.3、1.4和1.5版本。从2000年到2003年，一个经过扩充了的新的伙伴组织制定了一个升级的UML规范，即UML 2.0。
```

```
由IBM的Bran Selic领导的定案任务组（Finalization Task Force，FTF）对这个版本进行了为期一年的评审，UML 2.0的正式版本于2005年初被OMG采纳。UML 2.0是对UML 1的重大修订，包括了大量的新增特性。此外，基于先前版本的经验，UML 2.0对先前版本的构造物做了很多的修改。可以在OMG的网站www.omg.org上获得当前的UML规范文档。

UML2.0解决了用户在使用UML1.x过程中所遇到的一些问题。
（1）用例图
       在UML2.0中，为每个用例增加了一个称为“Subject”的特征，这项特征的取值可以作为在逻辑层面划分一组用例的一项依据。用例所属的“系统边界”就是“Subject”的一种典型例子。
（2）顺序图
       对于顺序图，UML2.0主要做了3方面的改进。
       ①允许顺序图中明确的表达分支判断逻辑。
       ②允许“纵向”与“横向” 对顺序图进行拆分与引用。
       ③提供了一种新图，称为“交互纵览图” 。
（3）活动图
       在UML2.0中，活动图增加了泳道、对象等特性。
（4）组件图
       组件所提供的接口、所要求的接口、组件之间的依赖关系通过“组装连接器” 更加明确地表达等。
（5）新增加的图
       增加了“包图”、“组合结构图”、“交互纵览图”和“计时图”。
```

## 2.5特点

- （1）UML统一了Booch、OMT和OOSE等方法中的基本概念和符号。

- （2）UML吸取了面向对象领域中各种优秀的思想，其中也包括非OO方法的影响。

- （3）UML在演变过程中还提出了一些新的概念。

  > 例如：模板（Stereotypes）、职责（Responsibilities）活动图（Activity diagram）等新概念。

# 3 概念模型

UML的组成共包括三部分：元素（事物）、图和关系。元素（事物）是UML中重要的组成部分。关系把元素（事物）紧密联系在一起。图是很多有相互关系的元素（事务）的组。

## 3.1 构造块

UML的词汇表包含下面3种构造块：
（1）事物；
（2）关系；
（3）图。
事物是对模型中首要成分的抽象；关系把事物结合在一起；图聚集了相关的事物。



### 3.1.1 事物

在UML中有4种事物，这些事物是UML中基本的面向对象的构造块，用它们可以写出形式良好的模型。



#### （1）结构事物

```
结构（构件）事物 （structural thing）是UML模型中的名词。它们通常是模型的静态部分，描述概念元素或物理元素。结构事物总称为类目（classifier）。

- （1）类
- （2）接口
- （3）协作
- （4）用例
- （5）构件
- （6）节点
```

```
第一，类 （class）是对一组具有相同属性、相同操作、相同关系和相同语义的对象的描述。类实现一个或多个接口。在图形上，把类画成一个矩形，矩形中通常包括类的名称、属性和操作，如下图3-1所示。
```



![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211631.png)

<center>图3-1 类</center>

```
第二，接口 （interface）是一组操作的集合，其中的每个操作描述了类或构件的一个服务。因此，接口描述了元素的外部可见行为。一个接口可以描述一个类或构件的全部行为或部分行为。接口定义了一组操作规约（即操作的特征标记），而不是操作的实现。接口的声明看上去像一个类，在名称的上方标注着关键字«interface»；除非有时用来表示常量，否则不需要属性。然而，接口很少单独出现。如下图3-2所示，把由类提供的对外接口表示成用线连接到类框的一个小圆圈，把类向其他类请求的接口表示成用线连接到类框的半个小圆圈。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211632.png)

<center>图3-2 接口</center>

```
第三，协作 （collaboration）定义了一个交互，它是由一组共同工作以提供某种协作行为的角色和其他元素构成的一个群体，这些协作行为大于所有元素的各自行为的总和。协作具有结构、行为和维度。一个给定的类或对象可以参与几个协作。这些协作因而表现了系统构成模式的实现。在图形上，把协作画成虚线椭圆，有时仅包含它的名称，如下图3-3所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211633.png)

<center>图3-3 协作</center>

```
第四，用况 （use case）是对一组动作序列的描述，系统执行这些动作将产生对特定的参与者有价值而且可观察的结果。用况用于构造模型中的行为事物。用况是通过协作实现的。在图形上，把用况画成实线椭圆，通常仅包含它的名称，如下图3-4所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211634.png)

<center>图3-4 用况</center>

```
剩余的3种事物——主动类、构件和结点，都和类相似，就是说它们也描述了一组具有相同属性、操作、关系和语义的实体。然而，这3种事物与类的不同点也不少，而且对面向对象系统的某些方面的建模是必要的，因此对这几个术语需要单独处理。
```



```
第五，主动类 （active class）是这样的类，其对象至少拥有一个进程或线程，因此它能够启动控制活动。主动类的对象所表现的元素的行为与其他元素的行为并发，除了这一点之外，它和类是一样的。在图形上，把主动类绘制成类图符，只是它的左右外框是双线，通常它包含名称、属性和操作，如图3-5所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211635.png)

<center>图3-5 主动类</center>



```
第六，构件 （component）是系统设计的模块化部件，将实现隐藏在一组外部接口背后。在一个系统中，共享相同接口的构件可以相互替换，只要保持相同的逻辑行为即可。可以通过把部件和连接件接合在一起表示构件的实现；部件可以包括更小的构件。在图形上，构件的表示很像类，只是在其右上角有一个特殊的图标，如图3-6所示。
```



![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211636.png)

<center>图3-6 构件</center>

```
 剩下的两种元素是制品和结点，它们也是不同的。它们表示物理事物，而前6种元素表示概念或逻辑事物。
```



```
第七，制品 （artifact）是系统中物理的而且可替换的部件，它包括物理信息（“比特”）。在一个系统中，会遇到不同类型的部署制品，如源代码文件、可执行程序和脚本。制品通常代表对源码信息或运行时信息的物理打包。在图形上，把制品画成一个矩形，在其名称的上方标注着关键字«artifact»，如图3-7所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211637.png)

<center>图3-7 制品</center>

```
第八，结点 （node）是在运行时存在的物理元素，它表示一个计算机资源，通常至少有一些记忆能力，还经常具有处理能力。一组构件可以驻留在一个结点内，也可以从一个结点迁移到另一个结点。在图形上，把结点画成一个立方体，通常在立方体中只写它的名称，如图3-8所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211638.png)

<center>图3-8 结点</center>



```
这些元素——类、接口、协作、用况、主动类、构件、制品和结点，是UML模型中可以包含的基本结构事物。它们也有变体，如参与者、信号、实用程序（几种类）、进程和线程（两种主动类）、应用、文档、文件、库、页和表（几种制品）等。
```







#### （2）行为事物

```
行为事物 behavioral thing）是UML模型的动态部分。它们是模型中的动词，代表了跨越时间和空间的行为。共有3类主要的行为事物。

第一，交互 （interaction）是这样一种行为，它由在特定语境中共同完成一定任务的一组对象或角色之间交换的消息组成。一个对象群体的行为或者单个操作的行为可以用一个交互来描述。交互涉及一些其他元素，包括消息、动作和连接件（对象间的连接）。在图形上，把消息画成一条有方向的直线，通常在其上总是带有操作名，如图3-9所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211639.png)

<center>图3-9 消息</center>

```
第二，状态机 （state machine）是这样一种行为，它描述了一个对象或一个交互在生命期内响应事件所经历的状态序列以及它对这些事件做出的响应。单个类或一组类之间协作的行为可以用一个状态机来描述。状态机涉及到一些其他元素，包括状态、转移（从一个状态到另一个状态的流）、事件（触发转换的事物）和活动（对一个转移的响应）。在图形上，把状态画成一个圆角矩形，通常在其中含有状态的名字及其子状态（如果有的话），如图3-10所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211640.png)

<center>图3-10 状态</center>

```
第三，活动 （activity）是这样一种行为，它描述了计算过程执行的步骤序列。交互所注重的是一组进行交互的对象，状态机所注重的是一定时间内一个对象的生命周期，活动所注重的是步骤之间的流而不关心哪个对象执行哪个步骤。活动的一个步骤称为一个动作。在图形上，把动作画成一个圆角矩形，在其中含有指明其用途的名字，如图3-11所示。状态和动作靠不同的语境得以区别。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211641.png)



<center>图3-11 动作</center>

```
交互、状态机和活动这3种元素是UML模型中可能包含的基本行为事物。在语义上，这些元素通常与各种结构元素（主要是类、协作和对象）相关。
```







#### （3）分组事物

```
分组事物是UML模型图的组织部分，描述事物的组织结构，主要由包来实现。
分组事物 （grouping thing）是UML模型的组织部分。它们是一些由模型分解成的“盒子”。主要的分组事物是包。
包 （package）是用于对设计本身进行组织的通用机制，与类不同，它是用来组织实现构造物的。结构事物、行为事物甚至其他的分组事物都可以放进包内。包不像构件（构件在运行时存在），它纯粹是概念上的（即它仅在开发时存在）。在图形上，把包画成带标签的文件夹（一个左上角带有一个小矩形的大矩形），在矩形中通常仅含有包的名称，有时还含有其内容，如图3-12所示。
包是用来组织UML模型的基本分组事物。它也有变体，如框架、模型和子系统（它们是包的不同种类）。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211642.png)

<center>图3-12 包</center>







#### （4）注释事物

```
注释事物是UML模型的解释部分，用来对模型中的元素进行说明，解释。
注释事物 （annotational thing）是UML模型的解释部分。这些注释事物用来描述、说明和标注模型中的任何元素。有一种主要的注释事物，称为注解。注解（note）是依附于一个元素或一组元素之上对它进行约束或解释的简单符号。在图形上，把注解画成一个右上角是折角的矩形，其中带有文字或图形解释，如图3-13所示。
该元素是可以包含在UML模型中的基本注释事物。通常可以用注解中所含的约束或解释来修饰图，最好是把注释表示成形式或非形式化的文本。这种元素也有变体，例如需求（从模型的外部来描述一些想得到的行为）。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211643.png)

<center>图3-13注解</center>





### 3.2.1 关系

- 在UML中有4种关系：依赖、关联、泛化和实现。这些关系是UML的基本关系构造块，用它们可以写出形式良好的模型。这4种元素是UML模型中可以包含的基本关系事物。它们也有变体，例如，精化、跟踪、包含和扩展。

#### （1）依赖（Dependency）

- 依赖是两个模型元素间的语义关系，其中一个元素（独立事务）发生变化会影响另一个元素（依赖事务）的语义。在图形上，把依赖画成一条可能有方向的虚线，偶尔在其上还带有一个标记。

```
第一，依赖 （dependency）是两个模型元素间的语义关系，其中一个元素（独立元素）发生变化会影响另一个元素（依赖元素）的语义。在图形上，把依赖画成一条可能有方向的虚线，有时还带有一个标记，如图3-14所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211644.png)

<center>图3-14依赖</center>



#### （2）关联（Association）

- 关联指明了一个对象与另一个对象间的关系。在图形上，关联用一条实线表示，它可能有方向，偶尔在其上还有一个标记。例如，读者可以去图书馆借书和还书，图书管理员可以管理书籍也可以管理读者的信息，显然在读者、书籍、管理员之间存在着某种联系。那么在用UML设计类图的时候，就可以在读者、书籍、管理员三个类之间建立关联关系。

```
第二，关联 （association）是类之间的结构关系，它描述了一组链，链是对象（类的实例）之间的连接。聚合是一种特殊类型的关联，它描述了整体和部分间的结构关系。在图形上，把关联画成一条实线，它可能有方向，有时还带有一个标记，而且它还经常含有诸如多重性和端名这样的修饰，如图3-15所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211645.png)

<center>图3-15关联</center>







#### （3）泛化（Generalization）

- 泛化是一种一般化——特殊化的关系，是一般事物（父类）和该事物较为特殊的种类（子类）之间的关系，子类继承父类的属性和操作，除此之外，子类还添加新的属性和操作。在图形上，把泛化关系画成带有空心箭头的实线，该实线指向父类。

```
泛化 （generalization）是一种特殊/一般关系，其中特殊元素（子元素）基于一般元素（父元素）而建立。用这种方法，子元素共享了父元素的结构和行为。在图形上，把泛化关系画成一条带有空心箭头的实线，该实线指向父元素，如图3-16所示。
```

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211646.png)



<center>图3-16 泛化</center>



#### （4）实现（Realization）

- 实现是类之间的语义关系，其中的一个类指定了由另一个类必须执行的约定。在两种地方会遇到实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用例和实现它们的协作之间。在图形上，把实现关系画成一条带有空心箭头的虚线，它是泛化和依赖关系两种图形的结合。

```
实现 （realization）是类目之间的语义关系，其中一个类目指定了由另一个类目保证执行的合约。在两种地方会遇到实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用况和实现它们的协作之间。在图形上，把实现关系画成一条带有空心箭头的虚线，它是泛化和依赖关系两种图形的结合，如图3-17所示。
```



![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211647.png)



<center>图3-17 实现</center>









### 3.2.3 图

图（diagram）是一组元素的图形表示，大多数情况下把图画成顶点（代表事物）和弧（代表关系）的连通图。为了对系统进行可视化，可以从不同的角度画图，这样一个图是对系统的投影。对所有的系统（除非很微小的系统）而言，图是系统组成元素的省略视图。有些元素可以出现在所有图中，有些元素可以出现在一些图中（很常见），还有些元素不能出现在图中（很罕见）。在理论上，图可以包含事物及其关系的任何组合。然而在实际中仅出现少量的常见组合，它们与组成软件密集型系统的体系结构的5种最有用的视图相一致。由于这个原因，UML包括13种这样的图：

```
（1）类图；
（2）对象图；
（3）构件图；
（4）组合结构图；
（5）用况图；
（6）顺序图；
（7）通信图；
（8）状态图；
（9）活动图；
（10）部署图；
（11）包图；
（12）定时图；
（13）交互概览图。
```



类图 （class diagram）展现了一组类、接口、协作和它们之间的关系。在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图。包含主动类的类图给出系统的静态进程视图。构件图是类图的变体。

 

对象图 （object diagram）展现了一组对象以及它们之间的关系。对象图描述了在类图中所建立的事物的实例的静态快照。和类图一样，这些图给出系统的静态设计视图或静态进程视图，但它们是从真实案例或原型案例的角度建立的。



构件图 （component diagram）展现了一个封装的类和它的接口、端口以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的（UML 将构件图和适用于任意类的组合结构图区分开来，但由于构件和结构化类之间的差别微不足道，所以一起讨论它们）。



用况图 （use case diagram）展现了一组用况、参与者（一种特殊的类）及它们之间的关系。用况图给出系统的静态用况视图。这些图在对系统的行为进行组织和建模上是非常重要的。



顺序图和通信图都是交互图。交互图（interaction diagram）展现了一种交互，它由一组对象或角色以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图（sequence diagram）是强调消息的时间次序的交互图；通信图（communication diagram）也是一种交互图，它强调收发消息的对象或角色的结构组织。顺序图和通信图表达了类似的基本概念，但每种图强调概念的不同视角，顺序图强调时间次序，通信图强调消息流经的数据结构。定时图（不包含在本书中）展现了消息交换的实际时间。



状态图 （state diagram）展现了一个状态机，它由状态、转移、事件和活动组成。状态图展现了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调由事件引发的对象行为，这非常有助于对反应式系统建模。



活动图 （activity diagram）将进程或其他计算的结构展示为计算内部一步一步的控制流和数据流。活动图专注于系统的动态视图。它对于系统的功能建模特别重要，并强调对象间的控制流程。



部署图 （deployment diagram）展现了对运行时的处理结点以及在其中生存的构件的配置。部署图给出了体系结构的静态部署视图。通常一个结点包含一个或多个制品。



制品图 （artifact diagram）展现了计算机中一个系统的物理结构。制品包括文件、数据库和类似的物理比特集合。制品常与部署图一起使用。制品也展现了它们实现的类和构件。（UML把制品图视为部署图的变体，但我们分别地讨论它们。）



包图 （package diagram）展现了由模型本身分解而成的组织单元以及它们的依赖关系。



定时图 （timing diagram）是一种交互图，它展现了消息跨越不同对象或角色的实际时间，而不仅仅是关心消息的相对顺序。交互概览图（interaction overview diagram）是活动图和顺序图的混合物。这些图有特殊的用法，本书不做讨论，更多的细节可参考The Unified Modeling Language Reference Manual。

并不限定仅使用这几种图，开发工具可以利用UML来提供其他种类的图，但到目前为止，这几种图在实际应用中是最常用的。



并不限定仅使用这几种图，开发工具可以利用UML来提供其他种类的图，但到目前为止，这几种图在实际应用中是最常用的。



## 3.2 规则

不能简单地把 UML 的构造块按随机的方式堆放在一起。像任何语言一样，UML 有一套规则，这些规则描述了一个形式良好的模型应该是什么样。形式良好的模型应该在语义上是自我一致的，并且与所有的相关模型协调一致。

UML有自己的语法和语义规则，用于：

- 命名——为事物、关系和图起的名字；
- 范围——使名字具有特定含义的语境；
- 可见性——这些名字如何让其他成分看见和使用；
- 完整性——事物如何正确、一致地相互联系；
- 执行——运行或模拟一个动态模型意味着什么。

在软件密集型系统的开发期间所建造的模型往往需要发展变化，并可以由许多人员以不同的方式、在不同的时间进行观察。由于这个原因，下述的情况是常见的，即开发组不但会建造一些形式良好的模型，也会建造一些像下面这样的模型：

- 省略——隐藏某些元素以简化视图；
- 不完全——可能遗漏了某些元素；
- 不一致——模型的完整性得不到保证。

在软件开发的生命期内，随着系统细节的展开和变动，不可避免地要出现这样一些不太规范的模型。UML 的规则鼓励（不是强迫）专注于最重要的分析、设计和实现问题，这将促使模型随着时间的推移而具有良好的结构。



## 3.3 公共机制

通过与具有公共特征的模式取得一致，可以使一座建筑更为简单和更为协调。房子可以按一定的结构模式（它定义了建筑风格）建造成维多利亚式的或法国乡村式的。对于UML也是如此。由于在UML中有4种贯穿整个语言且一致应用的公共机制，因此使得UML变得较为简单。这4种机制是：

（1）规约；

（2）修饰；

（3）通用划分；

（4）扩展机制。

### 3.3.1 规约

UML 不仅仅是一种图形语言。实际上，在它的图形表示法的每部分背后都有一个规约，这个规约提供了对构造块的语法和语义的文字叙述。例如，在类的图符背后有一个规约，它提供了对该类所拥有的属性、操作（包括完整的特征标记）和行为的全面描述；在视觉上，类的图符可能仅展示了这个规约的一小部分。此外，可能存在着该类的另一个视图，其中提供了一个完全不同的部件集合，但是它仍然与该类的基本规约相一致。UML 的图形表示法用来对系统进行可视化；UML 的规约用来说明系统的细节。假定把二者分开，就可能进行增量式的建模。这可以通过以下方式完成：先画图，然后再对这个模型的规约增加语义，或直接创建规约，也可能对一个已经存在的系统进行逆向工程，然后再创建作为这些规约的投影的图。

UML 的规约提供了一个语义底版，它包含了一个系统的各个模型的所有部分，各部分以一致的方式相互联系。因此，UML 的图只不过是对底版的简单视觉投影，每一个图展现了系统的一个特定的关注方面。

### 3.3.2修饰

UML中的大多数元素都有唯一而直接的图形表示符号，这些图形符号对元素的最重要的方面提供了可视化表示。例如，特意把类的符号设计得容易画出，这是因为在面向对象系统建模中，类是最常用的元素；类的图形符号展示了类的最重要方面，即它的名称、属性和操作。

对类的规约可以包含其他细节，例如，它是否为抽象类，或它的属性和操作是否可见。可以把很多这样的细节表示为图形或文字修饰，放到类的基本矩形符号上。例如，下图3-18表示的是一个带有修饰的类，图中表明这个类是一个抽象类，有两个公共操作、一个受保护操作和一个私有操作。

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211648.png)

<center>图3-18 修饰</center>

UML表示法中的每一个元素都有一个基本符号，可以把各种修饰细节加到这个符号上。

### 3.3.3 通用划分

在对面向对象系统建模中，通常有几种划分方式。

第一种方式是对类和对象的划分。类是一种抽象，对象是这种抽象的一个具体表现。在UML中，可以对类和对象建立模型，如下图3-19所示。在图形上，UML是这样区分对象的：采用与类同样的图形符号来表示对象，并且在对象名的下面画一道线。

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211649.png)

<center>图3-19 类和对象</center>

 在这个图中，有一个名称为Customer的类，它有3个对象，分别为Jan（它被明确地标记为Customer的对象），:Customer（匿名的Customer对象）和Elyse（它在规约中被说明为一种Customer对象，尽管在这里没有明确地表示出来）。

UML的每一个构造块几乎都存在像类/对象这样的二分法。例如，可以有用况和用况执行、构件和构件实例、结点和结点实例等。

第二种方式是接口和实现的分离。接口声明了一个合约，而实现则表示了对该合约的具体实施，它负责如实地实现接口的完整语义。在UML中，既可以对接口建模又可以对它们的实现建模，如图3-20所示。

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211650.png)

<center>图3-20 接口和实现</center>

在这个图中，有一个名称为SpellingWizard.dll的构件，它实现了接口IUnknown和接口ISpelling，并且还需要一个由其他构件提供的名为IDictionary的接口。

几乎每一个UML的构造块都有像接口/实现这样的二分法。例如，用况和实现它们的协作，操作和实现它们的方法。

第三种方式是类型和角色的分离。类型声明了实体的种类（如对象、属性或参数），角色描述了实体在语境中的含义（如类、构件或协作等）。任何作为其他实体结构中的一部分的实体（例如属性）都具有两个特性：从它固有的类型派生出一些含义，从它在语境中的角色派生出一些含义（如图3-21所示）。

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211651.png)





<center>图3-21 具有角色和类型的部件</center>



### 3.3.4扩展机制

UML 提供了一种绘制软件蓝图的标准语言，但是一种闭合的语言即使表达能力再丰富，也难以表示出各种领域中的各种模型在不同时刻所有可能的细微差别。由于这个原因，UML 是目标开放的，使人们能够以受控的方式来扩展该语言。UML的扩展机制包括：

衍型；

标记值；

约束。

衍型 （stereotype）扩展了UML的词汇，可以用来创造新的构造块，这个新构造块既是从现有的构造块派生的，但是针对专门的问题。例如，假设正在使用一种编程语言，如Java或C++，经常要对“异常事件”建模。在这些语言里，“异常事件”就是类，只是用很特殊的方法进行了处理。通常可能只想允许抛出和捕捉异常事件，没有其他要求。此时可以让异常事件在模型中成为“一等公民”——可以像对待基本构造块一样对待它们，只要用一个适当的衍型来标记它们即可。请看图3-22中的类Overflow。



![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211652.png)



<center>图3-22 扩展机制</center>

 

标记值 （tagged value）扩展了UML衍型的特性，可以用来创建衍型规约的新信息。例如，如果在制作以盒装形式销售的产品，随着时间的推移，它经过了多次发行，那么经常会想要跟踪产品的版本和对产品做关键摘要的作者。版本和作者不是UML的基本概念，通过引入新的标记值，可以把它们加到像类那样的任何构造块中去。例如，在上图中，在类EventQueue上明确标记了版本和作者，这样就对该类进行了扩展。

约束 （constraint）扩展了UML构造块的语义，可以用来增加新的规则或修改现有的规则。例如，可能想约束类 EventQueue，以使所有的增加都按序排列。如上图所示，对操作 add增加了一个约束，即{ordered}，以明确标示这一规则。

总的来说，这3种扩展机制允许根据项目的需要来塑造和培育UML。这些机制也使得UML适合于新的软件技术（例如，很可能出现的功能更强的分布式编程语言）。可以增加新的构造块，修改已存在的构造块的规约，甚至可以改变它们的语义。当然，以受控的方式进行扩展是重要的，这样可以不偏离UML的目标——信息交流。

# 4 体系结构

可视化、详述、构造和文档化一个软件密集型系统，要求从几个角度去观察系统。各种人员——最终用户、分析人员、开发人员、系统集成人员、测试人员、技术资料作者和项目管理者——各自带着项目的不同日程，在项目的生命周期内各自在不同的时间、以不同的方式来看系统。系统体系结构或许是最重要的制品，它可以驾驭不同的视点，并在整个项目的生命周期内控制对系统的迭代和增量式开发。

体系结构是一组有关下述内容的重要决策：

软件系统的组织；

对组成系统的结构元素及其接口的选择；

像元素间的协作所描述的那样的行为；

将这些结构元素和行为元素组合到逐步增大的子系统中；

指导这种组织的体系结构风格：静态和动态元素以及它们的接口、协作和组成。

软件体系结构不仅关心结构和行为，而且还关心用法、功能、性能、弹性、复用、可理解性、经济与技术约束及其折中，以及审美的考虑。

如图4-1所示，最好用5个互连的视图来描述软件密集型系统的体系结构。每一个视图是在一个特定的方面对系统的组织和结构进行的投影。这5种视图中的每一种都可单独使用，使不同的人员能专注于他们最为关心的体系结构问题。这5种视图也会相互作用，如部署视图中的结点拥有实现视图的构件，而这些构件又表示了设计视图和交互视图中的类、接口、协作以及主动类的物理实现。UML允许表达这5种视图中的任何一种。

 ![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200117211653.png)

<center>图4-1 对系统的体系结构建模<center>



## 4.1 用例（况）视图

- 用例视图主要描述一个系统应该具备的功能，指的是从系统的外部参与者所能看到的系统功能。用例表示的是系统的一个功能单元，可以被描述为参与者与系统之间的一次交互作用。
- 用例模型的用途主要是列举出系统中的用例和参与者，并指出哪个参与者参与了哪个用例的执行。用例视图是其他4种视图的核心，它的内容直接驱动其他视图的开发。
- 系统的用况视图 （use case view）由描述可被最终用户、分析人员和测试人员看到的系统行为的用况组成。用况视图实际上没有描述软件系统的组织，而是描述了形成系统体系结构的动力。在UML中，该视图的静态方面由用况图表现；动态方面由交互图、状态图和活动图表现。

## 4.2 实现（逻辑）视图

- 系统的实现视图 （implementation view）包含了用于装配与发布物理系统的制品。这种视图主要针对系统发布的配置管理，它由一些独立的文件组成；这些文件可以用各种方法装配，以产生运行系统。它也关注从逻辑的类和构件到物理制品的映射。在UML中，该视图的静态方面由构件图表现，动态方面由交互图、状态图和活动图表现。
- 逻辑视图主要用于描述在用例视图中提出的系统功能的实现。逻辑视图主要关注系统的内部，它既描述系统的静态结构（系统中的类、对象以及他们之间的关系），也描述系统的动态协作关系。
- 逻辑视图的使用者主要是系统的设计人员和开发人员。

## 4.3 交互（并发）视图

- 系统的交互视图 （interaction view）展示了系统的不同部分之间的控制流，包括可能的并发和同步机制。该视图主要针对性能、可伸缩性和系统的吞吐量。在UML中，对该视图的静态方面和动态方面的表现与设计视图相同，但着重于控制系统的主动类和在它们之间流动的消息。
- 并发视图主要是从资源的有效利用、代码的并行执行以及系统环境中异步事件的处理等方面的考虑。将系统划分为并发执行的控制。
- 并发视图的使用者是开发人员和系统集成人员。

## 4.4 设计（组件）视图

- 系统的设计视图 （design view）包含了类、接口和协作，它们形成了问题及其解决方案的词汇。这种视图主要支持系统的功能需求，即系统应该提供给最终用户的服务。在UML中，该视图的静态方面由类图和对象图表现；动态方面由交互图、状态图和活动图表现。类的内部结构图特别有用。
- 组件视图描述系统的实现模块以及它们之间的依赖关系。其中，组件指的是不同类型的代码模块，它是构造应用的软件单元。组件视图中也可以添加组件的其他附加信息，例如，资源分配或者其他管理信息。
- 组件视图主要由组件图构成。组件视图的使用者是开发人员。

## 4.5 部署视图

- 系统的部署视图 （deployment view）包含了形成系统硬件拓扑结构的结点（系统在其上运行）。这种视图主要描述组成物理系统的部件的分布、交付和安装。在UML中，该视图的静态方面由部署图表现，动态方面由交互图、状态图和活动图表现。
- 部署视图，也称之为配置视图。配置视图主要显示系统的物理部署，它描述位于节点上的运行实例的部署情况。配置视图主要由配置图表示，配置视图还允许评估分配结果和资源分配。
- 配置视图的使用者是开发人员、系统集成人员和测试人员。





# 5.配置

在UML的发展中有很多工具被使用，其中比较有代表性的有Rational Rose、PowerDesigner等，这里提出四种工具加以介绍 

## 5.1 Rational Rose

Rational Rose是Rational公司出品的一种面向对象的统一建模语言的可视化建模工具。用于可视化建模和公司级水平软件应用的组件构造。ROSE是直接从UML发展而诞生的设计工具，它的出现就是为了对UML建模的支持， R

ational Rose包括了统一建模语言（UML）、OOSE和OMT。其中统一建模语言（UML）由Rational公司三位世界级面向对象技术专家Grady Booch、Ivar Jacobson和Jim Rumbaugh通过对早期面向对象研究和设计方法的进一步扩展得来的，它为可视化建模软件奠定了坚实的理论基础。 

## 5.2 Microsoft Office Visio

Microsoft Office Visio是微软公司出品的软件，Office Visio 提供了各种模板：业务流程的流程图、网络图、工作流图、数据库模型图和软件图，这些模板可用于可视化和简化业务流程、跟踪项目和资源、绘制组织结构图、映射网络、绘制建筑地图以及优化系统。

Visio有两个版本：Microsoft Office Visio Professional和 Microsoft Office Visio Standard。Office Visio Standard具备Office Visio Professional 包含的许多功能，但是Office Visio Professional还包含更多图表类型的模板以及若干项高级功能。 

## 5.3 PowerDesigner

PowerDesigner是Sybase公司的CASE工具集，使用它可以方便地对管理信息系统进行分析设计，它几乎包括了数据库模型设计的全过程。 利用PowerDesigner可以制作数据流程图、概念数据模型、物理数据模型，可以生成多种客户端开发工具的应用程序，还可为数据仓库制作结构模型，也能对团队设备模型进行控制。 它可与许多流行的数据库设计软件，例如：PowerBuilder，Delphi，VB等相配合使用来缩短开发时间和使系统设计更优化。 

## 5.4 StarUML

StarUML（简称SU），是一款开放源码的UML开发工具，是由韩国公司主导开发出来的产品，可以直接到StarUML网站下载。 

StarUML（简称SU），是一种创建UML类图，生成类图和其他类型的统一建模语言（UML）图表的工具。StarUML是一个开源项目之一发展快、灵活、可扩展性强。 



# 6.总结

通过本课程的学习对UML建模有了初步的了解，在本文中，通过简要介绍建模概述引出UML，主要从UML的概念模型和体系结构两个方面对UML进行简要介绍，篇幅所限，并未从使用角度进行介绍和分析，在UML中图的使用是建模重点，通过本课程的学习和书本学习的相关知识整理在<https://zlogs.net/learn-uml/>，后续实际开发中使用心得也将在此处更新，在一个学期的学习和使用中，对用例图、活动图和类图较为熟悉，后续学习将不断深入理解其他建模思想以及建模方法，从而充分运用UML解决实际问题，本文主要参考邵维忠老师译著的《UML用户指南（第二版）》以及老师课堂所讲内容。













