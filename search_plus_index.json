{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/1017.html":{"url":"page/1017.html","title":"背景拓展","keywords":"","body":""},"page/1019.html":{"url":"page/1019.html","title":"软件建模概述","keywords":"","body":"软件建模概述 1、软件建模的概念 模型是对现实存在的实体进行抽象和简化，模型提供了系统的蓝图。模型过虑了非本质的细节信息，使问题更容易理解。 为建立复杂的软件系统，我们必须抽象出系统的不同视图，使用精确的符号建立模型，验证这些模型是否满足系统的需求，并逐渐添加细节信息把这些模型转变为实现。这就是软件建模。这样的一个过程就是软件模型形成的过程，软件建模是捕捉系统本质的过程，把问题领域转移到解决领域的过程。 什么是建模 建模是一项经过检验并被广为接受的工程技术。建立房屋和大厦的建筑模型，能帮助用户得到实际建筑物的印象，甚至可以建立数学模型来分析大风或地震对建筑物造成的影响。 建模不只适用于建筑业。如果不首先构造模型（从计算机模型到物理风洞模型，再到与实物大小一样的原型），就装配新型的飞机或汽车，那简直是难以想象的。新型的电气设备（从微处理器到电话交换系统）需要一定程度的建模，以便更好地理解系统并与他人交流思想。在电影业，情节串联板是产品的核心，这也是建模的一种形式。在社会学、经济学和商业管理领域也需要建模，以证实人们的理论或用最小限度的风险和代价试验新的理论。 那么，模型是什么？简单地说： 模型是对现实的简化。 模型提供了系统的蓝图。模型既可以包括详细的计划，也可以包括从很高的层次考虑系统的总体计划。一个好的模型包括那些有广泛影响的主要元素，而忽略那些与给定的抽象水平不相关的次要元素。每个系统都可以从不同的方面用不同的模型来描述，因而每个模型都是一个在语义上闭合的系统抽象。模型可以是结构性的，强调系统的组织。它也可以是行为性的，强调系统的动态方面。 为什么要建模？一个基本理由是： 建模是为了能够更好地理解正在开发的系统。 通过建模，要达到以下4个目的。 （1）模型有助于按照实际情况或按照所需要的样式对系统进行可视化。 （2）模型能够规约系统的结构或行为。 （3）模型给出了指导构造系统的模板。 （4）模型对做出的决策进行文档化。 2、软件建模的用途 软件模型就是对复杂问题进行分层，从而更好地解决问题。 有效的软件模型有利于分工与专业化生产，从而节省生产成本。 对于软件人员来说，模型就好像是工程人员的图纸一样重要。 为什么要建模 成功的软件组织应该总是能够交付满足其用户需要的软件。如果一个软件组织能够及时并可预测地开发出这样的软件，并能够有效地利用人力和物力资源，那么这个软件组织就是可持续发展的。 在上段话里有一个重要的含义：一个开发队伍的主要产品不应该是一堆漂亮的文档、世界级的会议、伟大的口号或者几行获得普利策奖金的源代码，而应该是满足不断发展的用户及其业务需要的优秀软件。其他的一切事情都是次要的。 不幸的是，很多软件组织把“次要的”和“不重要的”的含义搞混了。为了得到满足预期功能的软件，必须到用户中去，以一种训练有素的方式访问用户，去揭示系统的真实需求。为了开发出具有持久质量的软件，必须打好能适应变化的、坚实的体系结构基础。为了能快速、有效地开发软件，尽量减少软件废品和重复工作，必须有合适的人员和合适的工具以及合适的工作重点。为了能一贯地、可预测地做到这些，并使得在整个系统的生命期内花费合理，必须有一个能适应业务和技术变化的合理的开发过程。 建模是开发优秀软件的所有活动中的核心部分，其目的是为了把想要得到的系统结构和行为沟通起来，为了对系统的体系结构进行可视化和控制，为了更好地理解正在构造的系统，并经常揭示简化和复用的机会，同时也是为了管理风险。 3、软件建模的优点 使用模型便于从整体上、宏观上把握问题，以便更好的解决问题。 软件建模可以加强软件工作人员之间的沟通。便于提早发现问题。 模型为代码生成提供依据，帮助我们按照实际情况对系统进行可视化。 模型允许我们详细说明系统的结构或行为。给出了一个指导我们构造系统的模板。并对我们做出的决策进行文档化。 建模的重要性 如果想搭一个狗窝，备好木料、钉子和一些基本工具（如锤子、锯和卷尺）之后，就可以开始工作了。从制订一点初步计划到完成一个满足适当功能的狗窝，可能不用别人帮助，在几个小时内就能够实现。只要狗窝够大且不太漏水，狗就可以安居。如果未能达到希望的效果，返工总是可以的，无非是让狗受点委屈。 如果想为家庭建造一所房子，备好木料、钉子和一些基本工具之后，也能开始工作，但这将需要较长的时间，并且家庭对于房子的需求肯定比狗对于狗窝的需求要多。在这种情况下，除非曾经多次建造过房子，否则就需要事先制定出一些详细的计划，再开始动工，才能够成功。至少应该绘制一些表明房子是什么样子的简图。如果想建造一所能满足家庭的需要并符合当地建筑规范的合格房屋，就需要画一些建筑图，以便能想清楚房间的使用目的以及照明、取暖和水管装置的实际细节问题。做出这些计划后，就能对这项工作所需的时间和物料做出合理的估计。尽管自己也可能建造出这样的房屋，但若有其他人协作，并将工程中的许多关键部分转包出去或购买预制的材料，效率就会高得多。只要按计划行事，不超出时间和财务的预算，家庭多半会对这新房感到满意。如果不制定计划，新房就不会完全令人满意。因此，最好在早期就制定计划，并谨慎地处理好所发生的变化。 如果你要建造一座高层办公大厦，若还是先备好木料、钉子和一些基本工具就开始工作，那将是非常愚蠢的。因为你所使用的资金可能是别人的，他们会对建筑物的规模、形状和风格做出要求。同时，他们经常会改变想法，甚至是在工程已经开工之后。由于失败的代价太高了，因此必须要做详尽的计划。负责建筑物设计和施工的是一个庞大的组织机构，你只是其中的一部分。这个组织将需要各种各样的设计图和模型，以供各方相互沟通。只要得到了合适的人员和工具，并对把建筑概念转换为实际建筑的过程进行积极的管理，将会建成这座满足使用要求的大厦。如果想继续从事建筑工作，那么一定要在使用要求和实际的建筑技术之间做好平衡，并且处理好建筑团队成员们的休息问题，既不能把他们置于风险之中，也不能驱使他们过分辛苦地工作以至于精疲力尽。 奇怪的是，很多软件开发组织开始想建造一座大厦式的软件，而在动手处理时却好像他们正在仓促地造一个狗窝。 有时你是幸运的。如果在恰当的时间有足够的合适人员，并且其他一切事情都很如意，你的团队有可能（仅是可能）推出一个令用户眼花缭乱的软件产品。然而，一般的情况下，不可能所有人员都合适（合适的人员经常供不应求），时间并不总是恰当的（昨天总是更好），其他的事情也并不尽如人意（常常由不得自己）。现在对软件开发的要求正在日益增加，而开发团队却还是经常单纯地依靠他们唯一真正知道如何做好的一件事——编写程序代码。英雄式的编程工作成为这一行业的传奇，人们似乎经常认为更努力地工作是面对开发中出现的各种危机的正常反应。然而，这未必能产生正确的程序代码，而且一些项目是非常巨大的，无论怎样延长工作时间，也不足以完成所需的工作。 如果真正想建造一个相当于房子或大厦类的软件系统，问题可不是仅仅编写许多软件。事实上，关键是要编出正确的软件，并考虑如何少写软件。要生产合格的软件就要有一套关于体系结构、过程和工具的规范。即使如此，很多项目开始看起来像狗窝，但随后发展得像大厦，原因很简单，它们是自己成就的牺牲品。如果对体系结构、过程或工具的规范没有作任何考虑，总有一天狗窝会膨胀成大厦，并会由于其自身的重量而倒塌。狗窝的倒塌可能使你的狗恼怒；同理，不成功的大厦则将对大厦的租户造成严重的影响。 不成功的软件项目失败的原因各不相同，而所有成功的项目在很多方面都是相似的。成功的软件组织有很多成功的因素，其中共同的一点就是对建模的采用。 4、建模原理 各种工程学科都有其丰富的建模运用历史。这些经验形成了建模的四项基本原理，现分别叙述如下。 第一，选择要创建什么模型，对如何动手解决问题和如何形成解决方案有着意义深远的影响 。 换句话说，就是要好好地选择模型。正确的模型将清楚地表明最棘手的开发问题，提供不能轻易地从别处获得的洞察力；错误的模型将使人误入歧途，把精力花在不相关的问题上。 暂时先把软件问题放在一边，假设现在正试图解决量子物理学上的一个问题。诸如光子在时空中的相互作用问题，其中充满了令人惊奇的难解的数学问题。选择一个不同的模型，所有的复杂问题一下子就变得可行了（虽然不容易解决）。在这个领域中，这恰恰是费曼图的价值，它提供了对非常复杂问题的图形表示。类似地，在一个完全不同的领域里，假设正在建造一座新建筑，将会关心疾风对它的影响。如果建立了一个物理模型，并拿到风洞中去实验，虽然小模型没有精确地反映出大的实物，但也可以从中找出一些有趣的东西。因此，如果正在建立一个数学模型，然后去模拟，将知道一些不同的东西；与使用物理模型相比，也可能获得更多新的场景。通过对模型进行严格的持续的实验，将更信任已经建模的系统，事实上，它在现实世界中将像期望的那样工作得很好。 对于软件而言，所选择的模型将在很大程度上影响对领域的看法。如果以数据库开发者的观点建造一个系统，可能会注意实体——联系模型，该模型把行为放入触发器和存储过程中。如果以结构化开发者的观点建造一个系统，可能得到以算法为中心的模型，其中包含从处理到处理的数据流。如果以面向对象开发者的观点建造一个系统，将可能得到这样一个系统：它的体系结构以一组类和交互模式（指出这些类如何一起工作）为中心。可执行的模型对测试有很大帮助。上述的任何一种方法对于给定的应用系统和开发文化都可能是正确的，然而经验表明，在构建有弹性的体系结构中面向对象的方法表现得更为出众，即使对使用大型数据库或计算单元的系统也是如此。尽管如此，但要强调一点，不同的方法将导致不同种类的系统，并且代价和收益也是不同的。 第二，可以在不同的精度级别上表示每一种模型 。 如果正在建造一座大厦，有时需要从宏观上让投资者看到大厦的样子，感觉到大厦的总体效果。而有时又需要认真考虑细节问题，例如，对复杂棘手的管道的铺设，或对罕见的结构件的安装等。 对于软件模型也是如此。有时一个快速简洁且是可执行的用户界面模型正是所需要的，而有时必须耐着性子对付比特，例如，描述跨系统接口或解决网络瓶颈问题就是如此。在任何情况下，最好的模型应该是这样的：它可以让你根据谁在进行观察以及为什么要观察选择它的详细程度。分析人员或最终用户主要考虑“做什么”的问题，开发人员主要考虑“怎样做”的问题。这些人员都要在不同的时间以不同的详细程度对系统进行可视化。 第三，最好的模型是与现实相联系的 。 如果一个建筑物的物理模型不能反映真实的建筑物，则它的价值是很有限的；飞机的数学模型，如果只是假定了理想条件和完美制造，则可能掩盖真实飞机的一些潜在的、致命的现实特征。最好是拥有能够清晰地联系实际的模型，而当联系很薄弱时能够精确地知道这些模型如何与现实脱节。所有的模型都对现实进行了简化；诀窍是，确保这种简化不要掩盖掉任何重要的细节。 软件领域中结构化分析的致命弱点是在分析模型和系统设计模型之间没有基本的联系。随着时间的推移，这个不可填充的裂缝会使系统构思阶段和实施阶段出现不一致。在面向对象的系统中，可以把各个几乎独立的系统视图连结成一个完整的语义整体。 第四，单个模型或视图是不充分的。对每个重要的系统最好用一小组几乎独立的模型从多个视角去逼近 。 如果正在建造一所建筑物，会发现没有任何一套单项设计图能够描述该建筑的所有细节。至少需要楼层平面图、立面图、电气设计图、采暖设计图和管道设计图。并且，在任何种类的模型中都需要从多视角来把握系统的范围（例如不同楼层的蓝图）。 在这里的重要短语是“几乎独立的”。在这个语境中，它意味着各种模型能够被分别进行研究和构造，但它们仍然是相互联系的。如同建造建筑物一样，既能够单独地研究电气设计图，但也能看到它如何映射到楼层平面图中，以及它与管道设计图中的管子排布的相互影响。 面向对象的软件系统也如此。为了理解系统的体系结构，需要几个互补和连锁的视图：用况视图（揭示系统的需求）、设计视图（捕获问题空间和解空间里的词汇）、交互视图（展示系统各部分之间以及系统与环境之间的联系）、实现视图（描述系统的物理实现）和部署视图（着眼于系统的工程问题）。每一种视图都可能有结构方面和行为方面。这些视图一起从整体上描绘了软件蓝图。 根据系统的性质，一些模型可能比另一些模型要重要。例如，对于数据密集型系统，表达静态设计视图的模型将占主导地位；对于图形用户界面密集型系统，静态和动态的用况视图就显得相当重要；在硬实时系统中，动态进程视图尤为重要；最后，在分布式系统中，例如 Web 密集型的应用，实现模型和部署模型是最重要的。 5、面向对象建模 土木工程师构造了很多种模型。通常这些模型能帮助人们可视化并说明系统的各部分以及这些部分之间的相互关系。根据业务或工程中所着重关心的内容（例如为了帮助研究一个结构在地震时的反应）工程师也可以建立动态模型。各种模型的组织是不同的，各有自己的侧重点。对于软件，有好几种建模的方法。最普通的两种方法是从算法的角度建模和从面向对象的角度建模。 传统的软件开发是从算法的角度进行建模。按照这种方法，所有的软件都用过程或函数作为其主要构造块。这种观点导致开发人员把精力集中于控制流程和对大的算法进行分解。这种观点除了常常产生脆弱的系统之外没有其他本质上的害处。当需求发生变化（总会变化的）以及系统增长（总会增长的）时，用这种方法建造的系统就会变得很难维护。 现代的软件开发采用面向对象的观点进行建模。按照这种方法，所有软件系统都用对象或类作为其主要构造块。简单地讲，对象通常是从问题空间或解空间的词汇中抽取出来的东西；类是对具有共同性质的一组对象（从建模者的视角）的描述。每一个对象都有标识（能够对它命名，以区别于其他对象）、状态（通常有一些数据与它相联系）和行为（能对该对象做某些事，它也能为其他对象做某些事）。 例如，可考虑把一个简单的计账系统的体系结构分成3层：用户界面层、业务服务层和数据库层。在用户界面层，将找出一些具体的对象，如按钮、菜单和对话框。在数据库层，将找出一些具体的对象，例如描述来自问题域实体的表，包括顾客、产品和订单等。在中间层，将找出诸如交易、业务规则等对象，以及顾客、产品和订单等问题实体的高层视图。 可以肯定地说，面向对象方法是软件开发方法的主流部分，其原因很简单，因为事实已经证明，它适合于在各种问题域中建造各种规模和复杂度的系统。此外，当前的大多数程序语言、操作系统和工具在一定程度上都是面向对象的，并给出更多按对象来观察世界的理由。面向对象的开发为使用构件技术（如J2EE或.NET）装配系统提供了概念基础。 选择以面向对象的方式观察世界，会产生一系列的问题：什么是好的面向对象的体系结构？项目会创造出什么样的制品？谁创造它们？怎样度量它们？ 对面向对象系统进行可视化、详述、构造和文档化正是统一建模语言（UML）的目的。 "},"page/1016.html":{"url":"page/1016.html","title":"面向对象","keywords":"","body":"面向对象 面向对象程序设计是一种新兴的程序设计方法，或者是一种新的程序设计规范，它使用对象、类、继承、封装、消息等基本概念来进行程序的设计。在面向对象方法中需要明确什么是对象，类，以及类的相关特征。对象（Object）是面向对象的基本构造单元。是系统中用来描述客观事物的一个实体，一个对象由一组属性和对属性进行操作的一组方法组成。一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。 基本概念 在学习面向对象程序设计之前，一般都会学习面向过程的程序设计，例如，使用C面向过程的程序设计语言，面向过程的语言是按流程化的思想来组织的。在这些语言的设计思想中，通常将存放基本数据类型的变量作为程序处理对象、以变量的赋值作为程序的基本操作、以变量值的改变作为程序运行的状态。这种程序设计风格存在着数据抽象简单、信息完全暴露、算法复杂、无法很好地描述客观世界等缺点。在程序设计过程中，为了实现有限度的代码重用，公共代码被组织成为过程或函数。当需要代码重用时，调用已经组织好的过程或函数。在这种应用方式中，如果软件项目庞大，程序的调试和维护将变得异常困难。 方法 面向对象方法具有以下几个要点： （1）面向对象的软件系统是由对象组成的，软件中的任何元素都是对象，复杂的软件对象由比较简单的对象组合而成。 （2）把所有对象都划分成各种对象类，每个对象类都定义了一组数据和一组方法，数据用于表示对象的静态属性，是对象的状态信息。 （3）按照子类与父类的关系，把若干个对象类组成一个层次结构的系统。 （4）对象彼此之间仅能通过传递消息进行联系。 对象 对象（Object）是面向对象的基本构造单元。是系统中用来描述客观事物的一个实体，一个对象由一组属性和对属性进行操作的一组方法组成。 对象不仅能表示具体的实体，也能表示抽象的规则、计划或事件。主要有如下的对象类型： （1）有形的实体：如汽车、书、计算机。 （2）作用：如医生、教师、员工、学生。 （3）事件：如飞行、事故、中断、开会等。 （4）性能说明：如车厂对车辆的性能说明，往往要列出型号及各种性能指标等。 类 一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。例如，窗口，车轮，玻璃等都是类的例子。 封装 封装（Encapsulation）就是把一个对象的方法和属性组合成一个独立的单位，并尽可能隐蔽对象的属性、方法和实现细节的过程。 对外访问时提供了4种访问控制级别： （1）public：公有访问。 （2）protected：受保护的。 （3）private：私有访问。 （4）default：默认的。 继承 继承（Inheritance）是一种一般类与特殊类的层次模型。继承性是指特殊类的对象具有其一般类的属性和方法，在其之上又增加了自己的特殊属性和方法。 在继承中，需要明确这样两个概念，子类和父类。 子类：指的是通过继承创建的新类称为“子类” 或者“派生类”。 父类：指的是被继承的类称为“基类”、“ 父类” 或“ 超类”。 继承性分为单重继承和多重继承两类。 单重继承：指的是一个子类只有一个父类； 多重继承：指的是一个子类可以有多个父类。 单重继承和多重继承时父类和子类之间的关系如图2.3所示，其中（a）表示的是单重继承，（b）表示的是多重继承。 多态 ​多态性（Polymorphism）是指类中同一函数名对应多个功能相似的不同函数，可以使用相同的调用方式来调用这些具有不同功能的同名函数，这些同名的函数可以是参数的个数或是类型不同，但是函数名相同，当进行调用的时候，根据所传的数据选定相应的函数，从而去执行不同的功能。如图2.4所示的就是多态性的表现 消息 消息是实现对象之间进行通信的一种机制，对于一个对象可以接收不同形式的多个消息，并产生不同的结果；相同形式的消息可以发送给不同的对象，并产生不同的结果；在发送消息的时候可以不考虑具体的接收者，对象可以对消息做出响应，也可以拒绝消息，也就是说不是必须要对消息做出响应。 通常，一个消息由以下几部分组成： （1）提供服务的对象名。 （2）服务的标识，即方法名。 （3）输入信息，即实际参数。 （4）响应结果，即返回值或操作结果。 面向对象开发 向对象方法的思想进行软件系统的开发过程共4个阶段： （1）系统调查和需求分析，分析问题并求解：对用户的开发需求进行调查和研究，这一个阶段通常称之为面向对象分析，即OOA。 （2）整理问题：对第一阶段的结果进一步抽象、归类，进行具体的设计，提出程序设计的思路和方法，这个阶段即为面向对象设计OOD。 （3）程序实现：面向对象编程OOP。 （4）系统测试：系统开发好后，在交付用户使用前，必须对程序进行严格的测试，这个阶段称为面向对象测试OOT。 传统系统开发共有5个阶段： 需求分析：是了解客户的需求、分析系统的可行性、分析需求的一致性及正确性等。 设计：是将需求转换为系统的重要过程。 实现：指的是通过程序语言，将所设计的内容转化为可以执行的软件系统。 除错：是实现活动中不可避免的工作，主要是修改程序编写过程中产生的错误。 测试：是对实现的程序代码模块进行检测，检验其功能是否正确、性能是否符合要求。 "},"page/1015.html":{"url":"page/1015.html","title":"软件开发生命周期","keywords":"","body":"软件开发生命周期 UML 在很大程度上是独立于过程的，这意味着它不依赖于任何特殊的软件开发生命周期。然而，为了从UML中得到最大的收益，应该考虑这样的过程，它是：用况驱动的；以体系结构为中心的；迭代的和增量的。 用况驱动 （use case driven）意味着把用况作为一种基本的制品，用于建立所要求的系统行为、验证和确认系统的体系结构、测试以及在项目组成员间进行交流。 以体系结构为中心 （architecture-centric）意味着以系统的体系结构作为一种基本制品，对被开发的系统进行概念化、构造、管理和演化。 迭代过程 （iterative process）是这样一种过程，它涉及到对一连串可执行的发布的管理。增量过程 （incremental process）是这样一种过程，它涉及到系统体系结构的持续集成，以产生各种发布，每个新的发布都比上一个发布有所改善。总的来讲，迭代和增量的过程是风险驱动的（risk-driven），这意味着每个新的发布都致力于处理和降低对于项目成功影响最为显著的风险。 这种用况驱动的、以体系结构为中心的、迭代/增量的过程可以分成几个阶段。阶段 （phase）是过程的两个主要里程碑之间的时间跨度，在阶段中将达到一组明确的目标，完成一定的制品，并做出是否进入到下一阶段的决策。如图2-24所示，在软件开发生命周期内有4个阶段：初始、细化、构造和移交。在图中，按这些阶段对工作流进行了划分，并显示了它们的焦点随时间的推移而变化的程度。 初始 （inception）是这个过程的第一个阶段。在此阶段，萌发的开发想法经过培育要达到这样一个目标：至少要在内部奠定足够的基础，以保证能够进入到细化阶段。 细化 （elaboration）是这个过程的第二个阶段。在此阶段定义产品需求和体系结构。在这个阶段，将明确系统需求，按其重要性排序并划定基线。可以按一般的描述，也可以按精确的评价准则来排列系统的需求，每个需求都说明了特定的功能或非功能的行为，并为测试提供了基础。 构造 （construction）是这个过程的第三个阶段，在此阶段软件从可执行的体系结构基线发展到准备移交给用户。针对项目的商业需要，这里也要不断地对系统的需求，特别是对系统的评价准则进行检查，并要适当地分配资源，以主动地降低项目的风险。 移交 （transition）是这个过程的第四个阶段，在此阶段把软件交付给用户。在这个阶段，软件开发过程很少能结束，还要继续改善系统，根除错误，增加早期发布未能实现的特性。 使得这个过程与众不同，并贯穿所有 4个阶段的要素是迭代。迭代 （iteration）是一组明确的工作任务，具有产生能运行、测试和评价的可执行系统的基准计划和评价准则。可执行系统无须向外发布。因为迭代产生可执行的产品，所以可以判断进展并在每次迭代后可重新估计风险。这意味着，软件开发生命周期具有以下特征：持续地发布系统体系结构的可执行版本，而且在每步迭代后可中途进行修改，以减少潜在的风险。正是因为强调将体系结构作为一个重要的制品，UML非常注重对系统体系结构的不同视图进行建模。 软件开发生命周期 "},"page/1010.html":{"url":"page/1010.html","title":"简介","keywords":"","body":"简介 是什么 UML（Unified Modeling Language统一建模语言），是一种能够描述问题、描述解决方案、起到沟通作用的语言。通俗的说，它是一种用文本、图形和符号的集合来描述现实生活中各类事物、活动、及其之间关系的语言。 统一建模语言（Unified Modeling Language，UML）是一种用于对软件密集型系统的制品进行可视化、详述、构造和文档化的图形语言。UML 给出了一种描绘系统蓝图的标准方法，其中既包括概念性的事物（如业务过程和系统功能），也包括具体的事物（如用特定的编程语言编写的类、数据库模式和可复用的软件构件）。 统一建模语言（Unified Modeling Language，UML）是一种绘制软件蓝图的标准语言。可以用UML对软件密集型系统的制品进行可视化、详述、构造和文档化。 从企业信息系统到基于Web的分布式应用，乃至硬实时嵌入式系统，都适合用UML来建模。UML是一种富有表达力的语言，可以描述开发所需要的各种视图，然后以此为基础来部署系统。虽然 UML 的表达力很丰富，但理解和使用它并不困难。要学习使用 UML，一个有效的出发点是形成该语言的概念模型，这要求学习3个要素：UML的基本构造块、支配这些构造块如何放置在一起的规则以及运用于整个语言的一些公共机制。 UML仅仅是一种语言，因此仅仅是软件开发方法的一部分。UML是独立于过程的，但最好把它用于以用况为驱动、以体系结构为中心、迭代和增量的过程。 UML是一种对软件密集型系统的制品进行下述工作的语言： 可视化； 详述； 构造； 文档化。 谁使用 进行软件开发、部署和维护的人员均可使用 UML。主要针对用 UML 进行建模的开发组成员，但它也适用于为了理解、建造、测试和发布一个软件密集型系统而一起工作的人员，因为他们要阅读这些模型。虽然这几乎包含了软件开发组织中的所有角色，分析员和最终客户（他们要详细说明系统应该具有的结构和行为）、体系结构设计人员（他们设计满足上述需求的系统）、开发人员（他们把体系结构转换为可执行的代码）、质量保证人员（他们检验并确认系统的结构和行为）、库管理人员（他们创建构件并对构件进行编目）、项目及程序管理者（他们一般是把握方向的领导者，要进行有序的管理，并合理地分配资源，以保证系统的成功交付）。 何处使用 UML主要用于软件密集型系统。在下列领域中已经有效地应用了UML： 企业信息系统； 银行与金融服务； 电信； 运输； 国防/航天； 零售； 医疗电子； 科学； 基于Web的分布式服务。 UML 不限于对软件建模。事实上，它的表达能力对非软件系统建模也是足够的。例如，法律系统的工作流程、病人保健系统的结构和行为、飞机战斗系统中的软件工程以及硬件设计等。 由什么组成 为了理解UML，需要形成该语言的概念模型，这要求学习建模的3个要素：UML的基本构造块、支配这些构造块如何放在一起的规则和一些运用于整个UML的公共机制。如果掌握了这些思想，就能够读懂UML模型，并能建立一些基本模型。当有了较丰富的应用UML的经验时，就能够在这些概念模型之上使用更高深的语言特征进行构造。 "},"page/1011.html":{"url":"page/1011.html","title":"发展","keywords":"","body":"发展 - 1994年10月，Grady Booch和Jim Rumbaugh于1995年10月发布第一个公开版本，称为统一方法UM 0.8。 - 1995年秋，Booch、Rumbaugh和Jacobson在1996年6月和10月分别发布了两个新的版本，UML 0.9和UML0.91，并将UM重新命名为UML（Unified Modeling Language）。 - 1996年，UML的开发者倡议成立了UML成员协会，以完善、加强和促进UML的定义工作。 - 1996年底，UML已稳占面向对象技术市场的85%，成为可视化建模语言事实上的工业标准。 - 1997年11月17日，OMG采纳UML 1.1作为基于面向对象技术的标准建模语言。 - 几年来，UML一直由OMG的修订任务组（Revision Task Force，RTF）维护，陆续研发了UML的1.3、1.4和1.5版本。从2000年到2003年，一个经过扩充了的新的伙伴组织制定了一个升级的UML规范，即UML 2.0。 由IBM的Bran Selic领导的定案任务组（Finalization Task Force，FTF）对这个版本进行了为期一年的评审，UML 2.0的正式版本于2005年初被OMG采纳。UML 2.0是对UML 1的重大修订，包括了大量的新增特性。此外，基于先前版本的经验，UML 2.0对先前版本的构造物做了很多的修改。可以在OMG的网站www.omg.org上获得当前的UML规范文档。 UML2.0解决了用户在使用UML1.x过程中所遇到的一些问题。 （1）用例图 在UML2.0中，为每个用例增加了一个称为“Subject”的特征，这项特征的取值可以作为在逻辑层面划分一组用例的一项依据。用例所属的“系统边界”就是“Subject”的一种典型例子。 （2）顺序图 对于顺序图，UML2.0主要做了3方面的改进。 ①允许顺序图中明确的表达分支判断逻辑。 ②允许“纵向”与“横向” 对顺序图进行拆分与引用。 ③提供了一种新图，称为“交互纵览图” 。 （3）活动图 在UML2.0中，活动图增加了泳道、对象等特性。 （4）组件图 组件所提供的接口、所要求的接口、组件之间的依赖关系通过“组装连接器” 更加明确地表达等。 （5）新增加的图 增加了“包图”、“组合结构图”、“交互纵览图”和“计时图”。 "},"page/1012.html":{"url":"page/1012.html","title":"特点","keywords":"","body":"特点 （1）UML统一了Booch、OMT和OOSE等方法中的基本概念和符号。 （2）UML吸取了面向对象领域中各种优秀的思想，其中也包括非OO方法的影响。 （3）UML在演变过程中还提出了一些新的概念。 例如：模板（Stereotypes）、职责（Responsibilities）活动图（Activity diagram）等新概念。 "},"page/1013.html":{"url":"page/1013.html","title":"配置","keywords":"","body":"配置 在UML的发展中有很多工具被使用，其中比较有代表性的有Rational Rose、PowerDesigner等，这里提出四种工具加以介绍 Rational Rose是Rational公司出品的一种面向对象的统一建模语言的可视化建模工具。用于可视化建模和公司级水平软件应用的组件构造。ROSE是直接从UML发展而诞生的设计工具，它的出现就是为了对UML建模的支持， R ational Rose包括了统一建模语言（UML）、OOSE和OMT。其中统一建模语言（UML）由Rational公司三位世界级面向对象技术专家Grady Booch、Ivar Jacobson和Jim Rumbaugh通过对早期面向对象研究和设计方法的进一步扩展得来的，它为可视化建模软件奠定了坚实的理论基础。 Microsoft Office Visio是微软公司出品的软件，Office Visio 提供了各种模板：业务流程的流程图、网络图、工作流图、数据库模型图和软件图，这些模板可用于可视化和简化业务流程、跟踪项目和资源、绘制组织结构图、映射网络、绘制建筑地图以及优化系统。 Visio有两个版本：Microsoft Office Visio Professional和 Microsoft Office Visio Standard。Office Visio Standard具备Office Visio Professional 包含的许多功能，但是Office Visio Professional还包含更多图表类型的模板以及若干项高级功能。 PowerDesigner是Sybase公司的CASE工具集，使用它可以方便地对管理信息系统进行分析设计，它几乎包括了数据库模型设计的全过程。 利用PowerDesigner可以制作数据流程图、概念数据模型、物理数据模型，可以生成多种客户端开发工具的应用程序，还可为数据仓库制作结构模型，也能对团队设备模型进行控制。 它可与许多流行的数据库设计软件，例如：PowerBuilder，Delphi，VB等相配合使用来缩短开发时间和使系统设计更优化。 StarUML（简称SU），是一款开放源码的UML开发工具，是由韩国公司主导开发出来的产品，可以直接到StarUML网站下载。 StarUML（简称SU），是一种创建UML类图，生成类图和其他类型的统一建模语言（UML）图表的工具。StarUML是一个开源项目之一发展快、灵活、可扩展性强。 "},"page/1021.html":{"url":"page/1021.html","title":"概念模型","keywords":"","body":"概念模型 UML的组成共包括三部分：元素（事物）、图和关系。元素（事物）是UML中重要的组成部分。关系把元素（事物）紧密联系在一起。图是很多有相互关系的元素（事务）的组。 "},"page/1020.html":{"url":"page/1020.html","title":"构造块1/3","keywords":"","body":"构造块 UML的词汇表包含下面3种构造块： （1）事物； （2）关系； （3）图。 事物是对模型中首要成分的抽象；关系把事物结合在一起；图聚集了相关的事物。 "},"page/1014.html":{"url":"page/1014.html","title":"事物","keywords":"","body":"事物 在UML中有4种事物，这些事物是UML中基本的面向对象的构造块，用它们可以写出形式良好的模型。 （1）结构事物 结构（构件）事物 （structural thing）是UML模型中的名词。它们通常是模型的静态部分，描述概念元素或物理元素。结构事物总称为类目（classifier）。 - （1）类 - （2）接口 - （3）协作 - （4）用例 - （5）构件 - （6）节点 第一，类 （class）是对一组具有相同属性、相同操作、相同关系和相同语义的对象的描述。类实现一个或多个接口。在图形上，把类画成一个矩形，矩形中通常包括类的名称、属性和操作，如下图所示。 类 第二，接口 （interface）是一组操作的集合，其中的每个操作描述了类或构件的一个服务。因此，接口描述了元素的外部可见行为。一个接口可以描述一个类或构件的全部行为或部分行为。接口定义了一组操作规约（即操作的特征标记），而不是操作的实现。接口的声明看上去像一个类，在名称的上方标注着关键字«interface»；除非有时用来表示常量，否则不需要属性。然而，接口很少单独出现。如下图所示，把由类提供的对外接口表示成用线连接到类框的一个小圆圈，把类向其他类请求的接口表示成用线连接到类框的半个小圆圈。 接口 第三，协作 （collaboration）定义了一个交互，它是由一组共同工作以提供某种协作行为的角色和其他元素构成的一个群体，这些协作行为大于所有元素的各自行为的总和。协作具有结构、行为和维度。一个给定的类或对象可以参与几个协作。这些协作因而表现了系统构成模式的实现。在图形上，把协作画成虚线椭圆，有时仅包含它的名称，如下图所示。 协作 第四，用况 （use case）是对一组动作序列的描述，系统执行这些动作将产生对特定的参与者有价值而且可观察的结果。用况用于构造模型中的行为事物。用况是通过协作实现的。在图形上，把用况画成实线椭圆，通常仅包含它的名称，如下图所示。 用况 剩余的3种事物——主动类、构件和结点，都和类相似，就是说它们也描述了一组具有相同属性、操作、关系和语义的实体。然而，这3种事物与类的不同点也不少，而且对面向对象系统的某些方面的建模是必要的，因此对这几个术语需要单独处理。 第五，主动类 （active class）是这样的类，其对象至少拥有一个进程或线程，因此它能够启动控制活动。主动类的对象所表现的元素的行为与其他元素的行为并发，除了这一点之外，它和类是一样的。在图形上，把主动类绘制成类图符，只是它的左右外框是双线，通常它包含名称、属性和操作，如图所示。 主动类 第六，构件 （component）是系统设计的模块化部件，将实现隐藏在一组外部接口背后。在一个系统中，共享相同接口的构件可以相互替换，只要保持相同的逻辑行为即可。可以通过把部件和连接件接合在一起表示构件的实现；部件可以包括更小的构件。在图形上，构件的表示很像类，只是在其右上角有一个特殊的图标，如图所示。 构件 剩下的两种元素是制品和结点，它们也是不同的。它们表示物理事物，而前6种元素表示概念或逻辑事物。 第七，制品 （artifact）是系统中物理的而且可替换的部件，它包括物理信息（“比特”）。在一个系统中，会遇到不同类型的部署制品，如源代码文件、可执行程序和脚本。制品通常代表对源码信息或运行时信息的物理打包。在图形上，把制品画成一个矩形，在其名称的上方标注着关键字«artifact»，如图所示。 制品 第八，结点 （node）是在运行时存在的物理元素，它表示一个计算机资源，通常至少有一些记忆能力，还经常具有处理能力。一组构件可以驻留在一个结点内，也可以从一个结点迁移到另一个结点。在图形上，把结点画成一个立方体，通常在立方体中只写它的名称，如图所示。 结点 这些元素——类、接口、协作、用况、主动类、构件、制品和结点，是UML模型中可以包含的基本结构事物。它们也有变体，如参与者、信号、实用程序（几种类）、进程和线程（两种主动类）、应用、文档、文件、库、页和表（几种制品）等。 （2）行为事物 行为事物 behavioral thing）是UML模型的动态部分。它们是模型中的动词，代表了跨越时间和空间的行为。共有3类主要的行为事物。 第一，交互 （interaction）是这样一种行为，它由在特定语境中共同完成一定任务的一组对象或角色之间交换的消息组成。一个对象群体的行为或者单个操作的行为可以用一个交互来描述。交互涉及一些其他元素，包括消息、动作和连接件（对象间的连接）。在图形上，把消息画成一条有方向的直线，通常在其上总是带有操作名，如图所示。 消息 第二，状态机 （state machine）是这样一种行为，它描述了一个对象或一个交互在生命期内响应事件所经历的状态序列以及它对这些事件做出的响应。单个类或一组类之间协作的行为可以用一个状态机来描述。状态机涉及到一些其他元素，包括状态、转移（从一个状态到另一个状态的流）、事件（触发转换的事物）和活动（对一个转移的响应）。在图形上，把状态画成一个圆角矩形，通常在其中含有状态的名字及其子状态（如果有的话），如图所示。 状态 第三，活动 （activity）是这样一种行为，它描述了计算过程执行的步骤序列。交互所注重的是一组进行交互的对象，状态机所注重的是一定时间内一个对象的生命周期，活动所注重的是步骤之间的流而不关心哪个对象执行哪个步骤。活动的一个步骤称为一个动作。在图形上，把动作画成一个圆角矩形，在其中含有指明其用途的名字，如图所示。状态和动作靠不同的语境得以区别。 动作 交互、状态机和活动这3种元素是UML模型中可能包含的基本行为事物。在语义上，这些元素通常与各种结构元素（主要是类、协作和对象）相关。 （3）分组事物 分组事物是UML模型图的组织部分，描述事物的组织结构，主要由包来实现。 分组事物 （grouping thing）是UML模型的组织部分。它们是一些由模型分解成的“盒子”。主要的分组事物是包。 包 （package）是用于对设计本身进行组织的通用机制，与类不同，它是用来组织实现构造物的。结构事物、行为事物甚至其他的分组事物都可以放进包内。包不像构件（构件在运行时存在），它纯粹是概念上的（即它仅在开发时存在）。在图形上，把包画成带标签的文件夹（一个左上角带有一个小矩形的大矩形），在矩形中通常仅含有包的名称，有时还含有其内容，如图所示。 包是用来组织UML模型的基本分组事物。它也有变体，如框架、模型和子系统（它们是包的不同种类）。 包 （4）注释事物 注释事物是UML模型的解释部分，用来对模型中的元素进行说明，解释。 注释事物 （annotational thing）是UML模型的解释部分。这些注释事物用来描述、说明和标注模型中的任何元素。有一种主要的注释事物，称为注解。注解（note）是依附于一个元素或一组元素之上对它进行约束或解释的简单符号。在图形上，把注解画成一个右上角是折角的矩形，其中带有文字或图形解释，如图所示。 该元素是可以包含在UML模型中的基本注释事物。通常可以用注解中所含的约束或解释来修饰图，最好是把注释表示成形式或非形式化的文本。这种元素也有变体，例如需求（从模型的外部来描述一些想得到的行为）。 注解 "},"page/1037.html":{"url":"page/1037.html","title":"关系","keywords":"","body":"关系 在UML中有4种关系：依赖、关联、泛化和实现。这些关系是UML的基本关系构造块，用它们可以写出形式良好的模型。这4种元素是UML模型中可以包含的基本关系事物。它们也有变体，例如，精化、跟踪、包含和扩展。 1、依赖（Dependency） 依赖是两个模型元素间的语义关系，其中一个元素（独立事务）发生变化会影响另一个元素（依赖事务）的语义。在图形上，把依赖画成一条可能有方向的虚线，偶尔在其上还带有一个标记。 第一，依赖 （dependency）是两个模型元素间的语义关系，其中一个元素（独立元素）发生变化会影响另一个元素（依赖元素）的语义。在图形上，把依赖画成一条可能有方向的虚线，有时还带有一个标记，如图所示。 依赖 2、关联（Association） 关联指明了一个对象与另一个对象间的关系。在图形上，关联用一条实线表示，它可能有方向，偶尔在其上还有一个标记。例如，读者可以去图书馆借书和还书，图书管理员可以管理书籍也可以管理读者的信息，显然在读者、书籍、管理员之间存在着某种联系。那么在用UML设计类图的时候，就可以在读者、书籍、管理员三个类之间建立关联关系。 第二，关联 （association）是类之间的结构关系，它描述了一组链，链是对象（类的实例）之间的连接。聚合是一种特殊类型的关联，它描述了整体和部分间的结构关系。在图形上，把关联画成一条实线，它可能有方向，有时还带有一个标记，而且它还经常含有诸如多重性和端名这样的修饰，如图所示。 关联 3、泛化（Generalization） 泛化是一种一般化——特殊化的关系，是一般事物（父类）和该事物较为特殊的种类（子类）之间的关系，子类继承父类的属性和操作，除此之外，子类还添加新的属性和操作。在图形上，把泛化关系画成带有空心箭头的实线，该实线指向父类。 泛化 （generalization）是一种特殊/一般关系，其中特殊元素（子元素）基于一般元素（父元素）而建立。用这种方法，子元素共享了父元素的结构和行为。在图形上，把泛化关系画成一条带有空心箭头的实线，该实线指向父元素，如图所示。 泛化 4、实现（Realization） 实现是类之间的语义关系，其中的一个类指定了由另一个类必须执行的约定。在两种地方会遇到实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用例和实现它们的协作之间。在图形上，把实现关系画成一条带有空心箭头的虚线，它是泛化和依赖关系两种图形的结合。 实现 （realization）是类目之间的语义关系，其中一个类目指定了由另一个类目保证执行的合约。在两种地方会遇到实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用况和实现它们的协作之间。在图形上，把实现关系画成一条带有空心箭头的虚线，它是泛化和依赖关系两种图形的结合，如图所示。 实现 "},"page/1022.html":{"url":"page/1022.html","title":"图","keywords":"","body":"图 UML中的图 图（diagram）是一组元素的图形表示，大多数情况下把图画成顶点（代表事物）和弧（代表关系）的连通图。为了对系统进行可视化，可以从不同的角度画图，这样一个图是对系统的投影。对所有的系统（除非很微小的系统）而言，图是系统组成元素的省略视图。有些元素可以出现在所有图中，有些元素可以出现在一些图中（很常见），还有些元素不能出现在图中（很罕见）。在理论上，图可以包含事物及其关系的任何组合。然而在实际中仅出现少量的常见组合，它们与组成软件密集型系统的体系结构的5种最有用的视图相一致。由于这个原因，UML包括13种这样的图： （1）类图； （2）对象图； （3）构件图； （4）组合结构图； （5）用况图； （6）顺序图； （7）通信图； （8）状态图； （9）活动图； （10）部署图； （11）包图； （12）定时图； （13）交互概览图。 类图 （class diagram）展现了一组类、接口、协作和它们之间的关系。在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图。包含主动类的类图给出系统的静态进程视图。构件图是类图的变体。 对象图 （object diagram）展现了一组对象以及它们之间的关系。对象图描述了在类图中所建立的事物的实例的静态快照。和类图一样，这些图给出系统的静态设计视图或静态进程视图，但它们是从真实案例或原型案例的角度建立的。 构件图 （component diagram）展现了一个封装的类和它的接口、端口以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的（UML 将构件图和适用于任意类的组合结构图区分开来，但由于构件和结构化类之间的差别微不足道，所以一起讨论它们）。 用况图 （use case diagram）展现了一组用况、参与者（一种特殊的类）及它们之间的关系。用况图给出系统的静态用况视图。这些图在对系统的行为进行组织和建模上是非常重要的。 顺序图和通信图都是交互图。交互图（interaction diagram）展现了一种交互，它由一组对象或角色以及它们之间可能发送的消息构成。交互图专注于系统的动态视图。顺序图（sequence diagram）是强调消息的时间次序的交互图；通信图（communication diagram）也是一种交互图，它强调收发消息的对象或角色的结构组织。顺序图和通信图表达了类似的基本概念，但每种图强调概念的不同视角，顺序图强调时间次序，通信图强调消息流经的数据结构。定时图（不包含在本书中）展现了消息交换的实际时间。 状态图 （state diagram）展现了一个状态机，它由状态、转移、事件和活动组成。状态图展现了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调由事件引发的对象行为，这非常有助于对反应式系统建模。 活动图 （activity diagram）将进程或其他计算的结构展示为计算内部一步一步的控制流和数据流。活动图专注于系统的动态视图。它对于系统的功能建模特别重要，并强调对象间的控制流程。 部署图 （deployment diagram）展现了对运行时的处理结点以及在其中生存的构件的配置。部署图给出了体系结构的静态部署视图。通常一个结点包含一个或多个制品。 制品图 （artifact diagram）展现了计算机中一个系统的物理结构。制品包括文件、数据库和类似的物理比特集合。制品常与部署图一起使用。制品也展现了它们实现的类和构件。（UML把制品图视为部署图的变体，但我们分别地讨论它们。） 包图 （package diagram）展现了由模型本身分解而成的组织单元以及它们的依赖关系。 定时图 （timing diagram）是一种交互图，它展现了消息跨越不同对象或角色的实际时间，而不仅仅是关心消息的相对顺序。交互概览图（interaction overview diagram）是活动图和顺序图的混合物。这些图有特殊的用法，本书不做讨论，更多的细节可参考The Unified Modeling Language Reference Manual。 并不限定仅使用这几种图，开发工具可以利用UML来提供其他种类的图，但到目前为止，这几种图在实际应用中是最常用的。 并不限定仅使用这几种图，开发工具可以利用UML来提供其他种类的图，但到目前为止，这几种图在实际应用中是最常用的。 "},"page/1030.html":{"url":"page/1030.html","title":"用例图","keywords":"","body":"用例图 用例图是从用户角度描述系统功能，并指出各功能的操作者。用例图展示了一组用例、参与者以及它们之间的关系。 "},"page/1038.html":{"url":"page/1038.html","title":"简介","keywords":"","body":"简介 1.用例模型 基本组成部分有用例、角色（或参与者）和系统。 2.用例 用例用于描述系统的功能，也就是从用户的角度来说，系统具体应包含哪些功能，帮助分析人员理解系统的行为，它是对系统功能的宏观的、整体的描述，一个完整的系统通常包含许多用例，每个用例具体说明应完成的功能；参与者是指那些与系统进行交互的外部实体，通常它是系统的一个用户，但它也可以是其它系统或硬件设备，总之凡是需要与系统进行交互的任何实体都可以称作参与者，用例往往必须向参与者传递一些数值，这些数值是参与者在系统中获得的信息。 2.1使用用例的主要目的 （1）明确系统应具备什么功能，这些功能是否满足客户的基本需求，并与系统开发人员达成一致。 （2）为系统的功能提供清晰一致的描述，用例模型应用于系统开发的整个过程，为后阶段的系统设计和开发工作打下良好的基础。 （3）为系统测试打下基础，可以用于验证最终实现的系统所完成的功能是否符合客户的最初需求。 （4）通过从需求的功能用例出发跟踪进入到系统中具体实现的类和方法，可以检查其是否正确。例如，通过下面这种方法可以简化对系统的修改和扩展：首先修改用例模型，针对受到影响的用例，找到相应的系统设计和实现部分，对其进行相应的修改即可。 3.用例图 用例图（Use Case Diagram）是显示一组用例、参与者以及它们之间关系的一种图。 用例图在UML中是非常特别的图形元素，它描述了用户希望如何使用一个系统。通过用例图可以知道谁将是系统相关的用户，他们希望系统提供什么样的服务，以及他们需要为系统提供的服务。 用例图从用户的角度而不是开发者的角度来描述对软件产品的需求，分析产品所需的功能和动态行为。用例图常用来对需求进行建模，用例图在系统的整个分析、设计和开发阶段是非常重要的，它的正确与否直接影响到客户对最终实现的产品的满意度。用例图被广泛使用在各种开发活动中，但它最常用于描述系统以及子系统。 3.1参与者 参与者（也可以称为角色，Actor）是系统外部的一个人或者物，它以某种方式参与了系统的执行过程。参与者不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此参与者可以是人，可以是事物，也可以是时间或其他系统等等。还有一点需要注意的是，参与者不是指人或事物本身，而是表示人或事物在系统中所扮演的角色。 例如，张明是图书馆的管理员，他参与图书管理系统的交互，这时他既可以作为管理员这个角色参与管理，也可以作为借书者向图书馆借书，在这里张明扮演了两个角色，是两个不同的参与者，即管理员和借阅者。因此，在“图书管理系统”中“借阅者”和“系统管理员”都是参与者。 客户给销售员发来传真订货， 销售员下班前将当日订货单汇总输入系统。谁是系统的参与者？ 分析：根据参与者的定义可知，此系统的参与者是销售员。 在需求分析中常见的权限控制问题，一般的用户只可以使用一些常规的操作，如查询等，而管理员除了常规操作之外还需要进行一些系统管理工作，如一些关键数据的增加、删除、修改等，操作员既可以进行常规操作又可以进行一些配置操作。 例如，在“图书管理系统”中，可以认为“读者”是“学生读者”和“教师读者”的泛化，而“学生读者”还可以具体化为“本科生读者”和“研究生读者”；同样，“图书管理员”也是“采购员”、“ 编目员”及“借阅人员”的泛化。下图表示出了参与者之间的泛化关系。 3.2用例 需求获取（Requirement Elicitation）是需求分析阶段的主体部分，其主要的工作就是要建立待开发系统的模型，而用例就是用于建立这种模型的最好方法。用例最初由Ivar Jackboson博士提出，后来被融合到UML的规范之中，成为描述需求的标准化体系。 用例是代表系统中各个项目相关人员之间根据系统的行为所达成的契约。用例描述了在不同条件下，针对某一项目相关人员的请求，系统对其作出的响应。也就是说用例指的是对一组动作的描述，系统通过执行这些动作将对用例的参与者产生可以看到的结果。用来描述参与者可以感受到的系统服务或功能。 例如，在图书管理系统中，用户可以进行“查询图书的基本信息”，“借书”以及“还书”，管理员可以对图书的基本信息进行管理，如“新增图书信息”、“修改图书信息”，“删除图书”等等操作。即这些操作都是系统提供的服务（功能），因此，这些都可以独立成为一个用例。执行这些操作的都是人（即参与者）。 用例在UML中通常用一个椭圆图形符号来表示。 例如，在文字处理程序中，“置正文的字体为宋体”是一个用例，在图书管理系统中“新增图书信息”、“借书”和“还书”也是用例，在超市管理系统中的“进货”也是一个用例，如图4.5所示。在这里可以看出，用例可大可小，有的用例可能比较简单，而有的可能就很复杂，如“置正文的字体为宋体”这个用例就比较简单，很容易实现，但是对于“进货”和“借书”这样的用例相对就比较复杂，可能需要花一些时间才能够实现。 3.3用例描述 从软件开发的角度，用例就是需求的文字性描述，主要是说明系统如何工作的功能性或行为性需求。用例图只是简单地用图形的方式描述了一下系统。实际上，用例是文本形式，不是图形。用例是作为人与人之间，尤其是没有受过专门培训的人员之间互相交流的一种手段。因此，编写用例的首选形式通常是简单的文本。因此对于每个用例，还需要有详细的说明，这样就可以让别人对这个系统有一个更加详细的了解，这时我们就需要写用例描述。 3.4用例之间的可视化表示 用例除了与参与者有关联关系外，用例之间也存在着一定的关系，如泛化关系、包含关系、扩展关系等。 3.4.1包含关系 包含关系指的是两个用例之间的关系，其中一个用例（称为基本用例，base use case）的行为包含了另一个用例（称为包含用例，inclusion use case）的行为。也就是说基本用例会用到包含用例，表示基本用例中重用包含用例中的步骤。在UML图中，使用带虚线箭头表示，并在线上标有>。 3.4.2扩展关系 扩展（extend）关系的基本含义与泛化关系类似。extend关系是对基本用例的扩展，基本用例是一个完整的用例，即使没有子用例的参与，也可以完成一个完整的功能。extend的基本用例中将存在一个扩展点，只有当扩展点被激活时，子用例才会被执行。在扩展关系中，对于扩展用例（extension use case）有更多的规则限制，即基本用例必须声明若干“扩展点”（extension point），而扩展用例只能在这些扩展点上增加新的行为和含义。扩展关系是从扩展用例到基本用例的关系，它说明扩展用例定义的行为如何插入到基本用例定义的行为中。也就是说，扩展用例并不在基本用例中显示 3.4.3泛化关系 泛化关系指的是一般与特殊的关系。当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其它的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系 3.4.4分组关系 在一些用例图中，用例的数目可能很多，这时就需要把这些用例组织起来。这种情况在一个系统包含很多子系统时就会出现。另一种可能就是，当你按顺序和用户会谈，收集系统需求时，每个需求必须用一个单独的用例来表达，这时就需要某种方式来对这些需求进行分类。 最直接的方法就是把相关的用例放在一个包中组织起来。一组用例可以放在一个文件夹中。 "},"page/1039.html":{"url":"page/1039.html","title":"举例","keywords":"","body":"举例 在传统的软件开发方法和早期的面向对象开发方法中，描述系统的功能需求都是使用自然语言。这样的做法使得系统没有一个统一的格式，随意性很大，容易产生理解上的歧义和不准确性。使用UML的用例图模型来做系统的需求，这些问题就得到了很好地解决。在前面已经详细地介绍了用例、用例图以及相关的一些概念，下面将利用上面的基础知识，结合具体的案例“图书管理系统”，根据系统的需求，创建用例图模型。 1. 识别出系统中的角色和用例 （1）如何从系统中识别出角色 获取系统用例首先要找出系统的角色。如何识别系统的角色？可以从系统要完成的业务中识别系统的角色。 通过与用户的交流，让用户回答一些问题来识别角色。可以参考以下问题：谁将使用系统的主要功能？谁需要系统的支持以完成其日常工作任务？谁负责维护、管理并保持系统正常运行？系统需要处理哪些硬设备？系统需要和哪些外部系统交互？系统运行产生的结果谁比较感兴趣？这几个问题的答案往往包括了所有与系统相关的用户。进一步分析这些用户，以及他们在系统中承担的作用就可以得到角色。 图书管理系统涉及读者信息管理、借阅信息管理、图书信息管理等多方面的信息管理。系统的使用对象为图书管理员和读者。他们在使用系统时，各拥有不同的权限，以完成各自需要的工作。 在图书管理系统中，图书管理员要为每个读者建立借阅账号，用于记录读者的个人基本信息和图书的借阅信息；读者的账号信息建立成功后，给读者发借阅证，这时读者就可以凭借该借阅证进行图书的借阅，或是通过网络进行图书信息的查询和检索。 读者在借阅图书时，需要出示借阅证，输入借阅证号，验证借阅证的有效性及是否可续借，无效则向读者提示原因，如，“卡号不对”，“已借满，不能续借”等，有效则显示读者的基本信息，例如读者的个人资料以及借阅图书的历史信息等，读者提出借阅申请后，管理员对借阅的图书进行登记。 相应的，当读者归还图书信息时，也需要对借阅证进行有效性的验证，如果不对，给读者提示相应的信息，验证通过后，显示读者的基本信息和借阅的图书信息等；读者向管理员归还图书，管理员验证无误后，删除读者对该书的借阅信息，如果超期，则读者需要缴纳一定的罚款才能归还。 此外，当涉及到图书信息变更时，例如，新增图书信息或是图书毁坏程度很大需要报损不能再使用时，图书管理员就需要将图书进行入库或是注销处理。同理，当有新增的借阅者或是要注销借阅者信息时也要做相应的处理。 （2）如何从系统中识别用例用例的获取是需求分析阶段的主要任务之一。但对于一个大系统，要直接列出用例清单常常是十分困难的。这时可先列出角色清单，再对每个角色列出它的用例，问题就会变得容易得多。在识别出了角色之后，就可以通过回答下述问题来帮助识别用例. 对图书管理系统进行需求分析以及第一部分得出的角色，可以得出每个角色相应的需求：其中图书管理员可实现如下操作：增加、删除和修改图书基本信息；增加、删除和修改读者信息；借书、归还图书记录的管理；查询读者基本信息、图书的基本信息。 借阅图书用例描述：借阅图书是图书管理系统中的一项基本功能，当读者能有效的登录到系统后就可以浏览图书的信息，进行借阅。 还书用例描述：还书是借书的逆过程，即要归还读者借阅的图书 。 新增图书用例描述。 注销图书用例：图书管理系统中对图书进行管理，图书有可能因为某些原因而损坏，不能再使用时，需要将其注销。 2. 区分用例优先次序 某些用例必须在其他用例之前完成，因为它们之间要相互依赖。例如，在系统借阅图书之前，必须记录图书的基本信息。因此很明显新增图书是最重要的用例。 3. 构建用例图模型 将已确定并细化的角色和用例放入用例图中。此时，再借助包含、扩展和泛化的关系给出用例之间的结构模型。 图书管理系统用例图图书管理系统按其业务功能分成读者管理、图书管理、借书、还书和用户管理等几部分，这些职能对应于系统不同组织部门。 （1）系统参与者 图书管理系统针对的对象是读者，图书管理员可以对图书信息进行管理。下图是管理系统参与者分析的用例图。其中，参与者“读者”是抽象角色。 （2）图书管理 图书馆中的图书根据需求进行更新是一项日常业务，因此在设计该系统时，也要为此设计用例，管理员成功登陆图书管理系统的书籍信息管理子系统，可以进行图书的新书入库、删除、修改等。图书管理的用例图如下图 4.超市进销存管理系统用例图 （1）超市进销存系统的需求 超市进销存系统的需求共包含销售管理、库存管理、订货管理和统计分析几部分： ①销售管理 售货员接收顾客订购，输入顾客购买的商品，计算总价。 顾客付款并接收清单。 售货员保存顾客购买商品的记录清单。 ②库存管理 库存管理员每天进行盘点一次。 库存管理员当发现库存商品有损坏时，及时到相关部门报损。 在供应商的商品到货时，库存管理员首先检查商品是否合格，并将合格的商品入库处理；当商品进入卖场时，进行商品出库处理。 经理、订货员根据需要进行库存商品的模糊查询或详细查询。 ③订货管理 订货员用新商品供应商信息更新供应商数据库的信息。 订货员统计库存商品是否低于库存下限，然后制作订货单。 ④统计分析 经理能够使用系统的统计功能，了解商品销售情况、库存情况、供应商情况，以便进行合理的营销策略。 经理按市场情况适时变动商品价格。 （2）建立超市进销存系统的用例图模型 超市进销存管理系统按其业务功能分成订货管理、销售管理、库存管理和统计分析四部分，这些功能对应于系统的不同组织部门。 ①系统角色 ②超市进销存管理系统的顶层用例图 ③销售管理子系统的用例图 ④订货管理子系统的用例图 ⑤库存管理子系统的用例图 ⑥统计分析子系统的用例图 ⑦身份验证子系统的用例图 用例建模是实现系统需求分析的一个很好的方法，使得系统分析员和用户之间能够更好的沟通系统的需求。用例图是显示一组用例、参与者以及它们之间关系的图。其中参与者在UML中通常以一个直立人的图形符号来表示；用例在UML中通常用一个椭圆图形符号来表示。用例与参与者之间具有关联关系，此外，用例之间也存在着泛化关系、包含关系、扩展关系等。面向对象和用例是UML中两个非常重要的基础概念。 "},"page/1023.html":{"url":"page/1023.html","title":"静态图","keywords":"","body":"静态图 "},"page/1024.html":{"url":"page/1024.html","title":"类图","keywords":"","body":"类图 类图是UML面向对象中最常用的一种图，类图可以帮助我们更直观的了解一个系统的体系结构。通过关系和类表示的类图，可以图形化的描述一个系统的设计部分。 "},"page/1040.html":{"url":"page/1040.html","title":"简介","keywords":"","body":"简介 类图在UML 的静态机制中是重要的组成部分，它不但是设计人员关心的核心，更是实现人员关注的重点。建模工具也主要根据类图来产生代码。类图在UML 的9个图中占据了一个相当重要的地位。 类图是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型，它用于描述系统的结构。类图的建模贯穿系统的分析和设计阶段的始终，通常从用户能够理解的用例开始建模，最终到系统开发小组能够完全理解的类。 概述 类是对一组具有相同属性、操作、关系和语义的对象的抽象。主要包括名称部分（Name）、属性部分（Attribute）和操作部分（Operation）。在UML中类用一个矩形框表示，它包含三个区域，最上面是类名、中间是类的属性、最下面是类的方法。 （1）名称 每个类都必须有一个能和其它类进行区分的名称，类的名称部分是不能省略的，其它组成部分可以省略。名称（Name）是一个文本串，类的命名要求由字符、数字、下划线组成的惟一的字符串即可。 （2）属性 属性描述了类在软件系统中代表的事物（即对象）所具备的特性。类可以有任意数目的属性，也可以没有属性。类如果有属性，则每一个属性都必须有一个名字，另外还可以有其它的描述信息，如可见性、数据类型、缺省值等。 在UML中，类属性的语法为： [可见性] 属性名 [:类型][=初始值] [{属性字符串}] ①可见性 类中属性的可见性主要包括公有（public）、私有（Private）和受保护（Protected）。 在UML中，用“+”表达公有类型，用“-”表达私有类型，而用“#”表达受保护类型。UML的类中不存在默认的可见性，如果没有显示任何一种符号，就表示没有定义该属性的可见性。（java默认可见性可以用~表示） ②属性名 每个属性都必须有一个名字以区别于类中的其他属性，是类的一个特性。 属性名由描述所属类的特性的名词或名词短语组成。按照UML的约定，单字属性名小写。如果属性名包含多个单词，这些单词要合并，且除了第一个单词外其余单词的首字母要大写。 ③类型 说明属性的数据类型。 在类的图标里，可以指定每个属性值的类型。可能的类型包括字符串（string）、浮点型（float）、整型（int）和布尔型（boolean）（以及其他的枚举类型）。指明类型时，需要在属性值后面加上类型名，中间用冒号隔开。还可以为属性指定一个缺省值。 ④初始值 为了保护系统的完整性，防止漏掉取值或被非法的值破坏系统的完整性，可以设定属性的初始值。 ⑤属性字符串 属性字符串用来指定关于属性的其他信息，例如某个属性应该是永久的。 任何希望添加在属性定义字符串值但又没有合适地方可以加入的规则，都可以放在属性字符串里。 （3）操作 操作是对类的对象所能做的事务的一个抽象。一个类可以有任意数量的操作或者根本没有操作。类如果有操作，则每一个操作也都有一个名字，其它可选的信息包括可见性、参数的名字、参数类型、参数缺省值和操作的返回值的类型等。 在UML中，类操作的语法为：[可见性] 操作名 [（参数表）][:返回类型] [{属性字符串}] （4）职责 在操作列表框下面的区域，你可以用来说明类的职责。职责位于操作部分下面的区域，可以用来说明类要做什么或说明另一个类的信息。类的职责可以是一个短语或一个句子。在UML中，把职责列在类图底部的分隔栏中 （5）约束 说明类的职责是消除二义性的一种非形式化的方法，形式化的方法是使用约束。约束指定了该类所要满足的一个或多个规则。在UML中，约束是用{}的格式写在类的边上，指定个别属性的取值范围。 在图书管理系统中的借阅者类，类名为借阅者，共有5个属性：借阅证号、是否有借阅资源、姓名、性别和类别；操作有借书和还书。如图5.3所示。在图5.3中，借阅者是类的名称，5个属性中，借阅证号、是否有借阅资源是私有属性（private），类型分别为int和boolean。姓名、性别和类别属性是公有属性，类型都是string。2个操作都是公有的（public），均没有返回值。 //用C++实现的程序如下： class Account { public: virtual double Deposite（double Amount）; virtual double ComputInterest（）; private: double balance=1; }; 接口 接口（interface）：是描述类的部分行为的一组操作，它也是一个类提供给另一个类的一组操作。通常接口被描述为抽象操作，也就是只用标识（返回值、操作名称、参数表）说明它的行为，而真正实现部分放在使用该接口的对象中，也就是说接口只负责定义操作而不具体的实现。 抽象类 抽象类是包含一种或多种抽象方法的类，它本身不需要构造实例。定义抽象类后，其它类可以对它进行扩充并且通过实现其中的抽象方法，使抽象类具体化。在UML中抽象类的图形表示和类图一样，只是在最上面一层的类名前加描述>或是在类的属性描述上设置该类为抽象类，抽象类的类名是斜体表示。 类之间的关系 关系是指事物之间的联系。在面向对象的建模中，类之间最常见的关系有：依赖关系、泛化关系、关联关系和实现关系。在图形上，把关系画成一条线，并用不同的线来区别关系的种类。 依赖关系 依赖关系（Dependency）表示两个或多个模型元素之间语义上的关系。它表示了这样一种情形，对于一个元素（服务提供者）的某些改变可能会影响或提供消息给其他元素（使用者），即使用者以某种形式依赖于其他类元。在UML图形上，把依赖画成一条有向的虚线，指向被依赖的事物。当要指明一个事物使用另一个事物时，就使用依赖。 （1）使用依赖 （2）抽象依赖 （3）授权依赖 （4）绑定依赖 在下图中模板类Stack定义了栈相关的操作；IntStack将参数T与实际类型int绑定，使得所有操作都针对int类型的数据。 //表示的bind依赖关系，使用C++生成的程序如下： template class Stack { private: int size; public: int Push（T elem）; int Pop（）; const T& GetTop（）; }; typedef Stack FloatStack; 泛化关系 泛化关系（Generalization）是一种存在于一般元素和特殊元素之间的分类关系，它只使用在类型上，而不是实例上。在类中，一般元素被称为超类或父类，而特殊元素被称为子类。在UML中，泛化关系用一条从子类指向父类的空心三角箭头表示 在下图中Account类是抽象类，SavingsAccount类是子类，继承父类的方法 //表示的泛化关系，使用C++生成的程序如下： class SavingsAccount : public Account { }; 关联关系 关联关系（Association）是一种结构关系，它指明一个事物的对象与另一个事物的对象之间的联系。也就是说，关联描述了系统中对象或实例之间的离散连接。给定一个连接两个类的关联，可以从一个类的对象联系到另一个类的对象。关联的两端都连接到一个类在理论上也是合法的。在UML图形中，关联关系用一条连接两个类的实线表示。 //表示的关联关系，使用C++生成的程序如下： // 类Library 的源码 public class Library { public Book theBook; public Library （） { } } // 类Book的源码 public class Book { public Library theLibrary; public Book （） { } } 在UML中，有4种可应用到关联的基本修饰：关联名、关联端的角色、关联端的多重性和聚合。 （1）关联名即名称（Name）（2）角色（Role）（3）多重性（Multiplicity）（4）聚合（Aggregation）（5）组合关系（Composition）（6）导航性（Nevigation）（7）关联类（8）约束 实现关系 实现将一种模型元素与另一种模型元素连接起来，比如类和接口。泛化和实现关系都可以将一般描述与具体描述联系起来。泛化将同一语义层上的元素连接起来，并且通常在同一模型内。实现关系则将不同语义层内的元素连接起来，通常建立在不同的模型内。 实现关系通常在两种情况下被使用：在接口与实现该接口的类之间；在用例以及实现该用例的协作之间。 "},"page/1041.html":{"url":"page/1041.html","title":"举例","keywords":"","body":"举例 类图的建模技术及应用 在软件开发不同阶段使用具有不同的抽象层次的类图，即概念层、说明层和实现层。在UML中，从开始的需求分析到最终的设计类，类图也是围绕着这三个层次的观点来进行建模的。类图建模是先建立概念层到说明层，进而到实现层，随着抽象层次的逐步降低并逐步细化的过程。下面从层次的角度来说明建立类图的过程。 1.概念层类图 概念层的类图描述的是现实世界中对问题领域的概念理解，类图中表达的类与现实世界的问题领域有着明显的对应关系，类之间的关系也与问题领域中实际事物的关系有着明显的对应关系。在概念层类图阶段很少考虑或者几乎不需要考虑类的实现问题。 2.说明层类图 在说明层阶段主要考虑的是类的接口部分，而不是实现部分。这个接口可能因为实现环境、运行特性等有多种不同的实现 3.实现层类图 真正需要考虑类的实现问题是在实现层类图阶段。提供实现的细节，在实现层阶段的类的概念才是真正的严格意义上的类。它揭示了软件实体的构成情况。说明层的类有助于人们对软件的理解，而实现层的类是最常用的得到类；利用RUP中如何在分析和设计中寻找类的步骤。 下面主要介绍几种类的识别方法。（1）名词识别法（2）从用例中识别类（3）使用CRC分析法（4）领域分析法 利用用例图对系统进行类图建模，在第2种方法中介绍的如何从用例图中分析类，学生成绩管理系统中的用例图如图所示 根据用例图进行类图的建模主要是确定系统需要的类以及类之间的关联和主要类的属性的描述 （1）确定类和关系 类之间的初步关系 类之间关系的细化 增加多重性 （2）确定属性和操作 细化属性和方法 学生成绩管理系统类图 ①Reader类 ②Borrow类 ③Book类 ④ReaderType类 ⑤Store类 ⑥BookType类 图书管理系统类图 类图在UML 的静态机制中是重要的组成部分，它不但是设计人员关心的核心，更是实现人员关注的重点。建模工具也主要根据类图来产生代码。类图在UML 的9个图中占据了一个相当重要的地位。 类图是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型，它用于描述系统的结构。类图的建模贯穿系统的分析和设计阶段的始终，通常从用户能够理解的用例开始建模，最终到系统开发小组能够完全理解的类。在本章中详细的介绍了类、类之间的关系，以及针对实际系统如何建类图模型，此外还介绍了对象和对象图及其相关的概念。 "},"page/1025.html":{"url":"page/1025.html","title":"对象图","keywords":"","body":"对象图 UML面向对象中对象图是类图的实例，几乎使用与类图完全相同的标识。它们的不同点在于对象图显示类的多个对象实例，而不是实例的类。一个对象图是类图的一个实例。由于对象存在生命周期，因此对象图只能在系统某一时间段存在。 "},"page/1042.html":{"url":"page/1042.html","title":"简介","keywords":"","body":"简介 类图是描述类、接口、协作以及它们之间关系的图，用来显示系统中各个类的静态结构。类图是定义其他图的基础，在类图基础上，可以使用状态图、协作图、组件图和配置图等进一步描述系统其他方面的特性。前面详细的介绍了类的基本概念，下面将针对对象进行具体的介绍以及将类和对象进行比较。 （1）什么是对象对象指的是一个单独的、可确认的物体、单元或实体，它可以是具体的也可以是抽象的，在问题领域里有确切定义的角色。换句话说，对象是边界非常清楚的任何事物。 （2）对象图 对象图（Object Diagram）描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。在UML中，对象图使用的是与类图相同的符号和关系，因为对象就是类的实例。 对象图在名称下面加下画线 "},"page/1043.html":{"url":"page/1043.html","title":"举例","keywords":"","body":"举例 "},"page/1026.html":{"url":"page/1026.html","title":"包图","keywords":"","body":"包图 "},"page/1044.html":{"url":"page/1044.html","title":"简介","keywords":"","body":"简介 "},"page/1045.html":{"url":"page/1045.html","title":"举例","keywords":"","body":"举例 "},"page/1031.html":{"url":"page/1031.html","title":"交互图","keywords":"","body":"交互图 "},"page/1032.html":{"url":"page/1032.html","title":"顺序图","keywords":"","body":"顺序图 顺序图由一组对象构成，每个对象分别带有一条竖线，称作对象的生命线，它代表时间轴，时间沿竖线向下延伸。 "},"page/1050.html":{"url":"page/1050.html","title":"简介","keywords":"","body":"简介 在标识出系统的类图之后，仅给出了实现用例的组成结构，还需要描述这些类的对象是如何交互来实现用例功能的。即不但需要把用例图模型转化为类图模型，还要将它转化为交互图模型。交互图表示类（对象）如何交互来实现系统行为。交互图包括顺序图和协作图两种。 本节主要介绍顺序图的概念、基本组成机建模过程。 顺序图（sequence diagram）是强调消息时间顺序的交互图，它描述了对象之间传送消息的时间顺序，用于表示用例中的行为顺序。顺序图将交互关系表示为一个二维图。横向轴代表了在协作中各独立对象的类元角色。纵向轴是时间轴，时间沿竖线向下延伸。 顺序图主要用于按照交互发生的一系列顺序，显示对象之间的这些交互。很象类图，开发者一般认为顺序图只对他们有意义。然而，一个组织的业务人员会发现，顺序图显示不同的业务对象如何交互，对于交流当前业务如何进行很有用。除记录组织的当前事件外，一个业务级的顺序图能被当作一个需求文件使用，为实现一个未来系统传递需求。在项目的需求阶段，分析师能通过提供一个更加正式层次的表达，把用例带入下一层次。那种情况下，用例常常被细化为一个或者更多的顺序图。在UML图中，顺序图与用例图和类图之间关系如图6.1所示。 图6.1 顺序图与用例图和类图之间关系图 顺序图的基本内容 顺序图中包括的建模元素主要有：角色（Actor）、对象（Object）、生命线（Lifeline）、激活（Activation）、消息（Message）等。 角色 系统角色（Actor）可以是人或其他的系统或者其子系统。 对象 顺序图中的对象（Object）在概念上和它在类图中的定义是一致的，它们之间可以进行交互，交互的顺序按时间的顺序。在顺序图中对象用矩形框表示，对象名带有下划线。 对象的左右顺序并不重要，但是为了图的清晰整洁，通常应遵循以下原则： 生命线 激活期 生命线（LiftLine）代表顺序图中对象在一段时间内的存在。生命线在顺序图中表示为从对象图标底部中心位置向下延伸的一条虚线（但事实上UML2中定义的生命线可以用实线来表示）。 激活期（Activation）也被称为控制焦点，代表顺序图中的对象执行一项操作的时期，是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。在UML中，用小矩形表示，被称为激活条或控制期，对象就是在激活条的顶部被激活的，在完成自己的工作后被去激活。 消息 消息（Message）是对象之间某种形式的通信，在垂直生命线之间，用带有箭头的线并附以消息表达式方式表示。它可以激发某个操作、唤起信号或导致目标对象的创建或撤销。一个对象到另一个对象的消息用跨越对象生命线的消息线表示。对象还可以发送消息给它自己，即消息线从自己的生命线出发又回到自己的生命线。 在UML中，消息的箭头形状代表了消息的类型。消息的类型分为同步消息，异步消息和同步且立即返回消息三种。 ① 同步消息（Synchronous Message） 仅当发送者要发送一个消息而且接收者已经做好接收这个消息的准备时才能传送的消息称为同步消息，即发送者和接收者同步。 UML用一个带有实心箭头的实线来表示这种类型的消息，如图6.6所示。 图6.6 同步消息符号 同步消息最常见的情况是调用，即消息发送者对象在它的一个操作执行时调用接收者对象的一个操作，此时消息名称就是被调用的操作名称。 假定有如下一个顺序图，如图6.7所示。 图6.7 顺序图实例 则可能的情形为ClassA具有类型为ClassB的属性，类ClassB具有action1的方法及类型为ClassC的属性；类ClassC具有action2和action3的方法。类ClassC和ClassB的定义片段如下： class ClassC{ public void action2() { } public void action3() { } } public class ClassB { private ClassC C=new ClassC(); public void action1() { C.action2(); C.action3(); } } 注：在图中显示的消息可以带有参数，但本部分采用StarUML开发工具，其参数不显示出来，而是放在属性窗口的Arguments中。同样的，消息也可以有返回值，放在Return属性中。 ② 异步消息（Asynchronous Message） 发送者不管接收者是否做好了接收准备都可以发送的消息称为异步消息。消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。 图6.8 异步消息符号 ③返回消息（Return Message） 返回消息表示从过程调用返回。 图6.9 返回消息图标 另外在消息的创建过程中还存在一些其他的内容，比如说创建对象、撤销对象、自关联消息等。 ①创建（create）对象 一个对象可以通过发送消息来创建另一个对象，即创建对象，如图6.10所示。对象在创建消息发生后才能存在，对象的生命线也是在创建消息后才存在。 图6.10 创建对象 ②撤销（destroy）对象 当一个对象被删除或自我删除时，该对象用“×”标记，即撤销对象，如图6.11所示。 图6.11 撤销对象 ③自关联消息（Self-Message） 表示方法的自身调用以及一个对象内的一个方法调用另外一个方法。如图6.12所示。 图6.12 自关联消息 6.1.3 约 束 当为对象的交互建模时，有时需要在某种条件满足时消息才会传递给对象。约束在UML图中用作控制流。一个约束只能被分配到一个单一消息。UML1.x中，为了实现约束条件，需要在消息名前加入约束条件，并放于“[]”中。约束条件用于描述代码中if语句结构。 例如，若b=1调用类Object2的message1方法；若b=2则调用类Object3的message2方法，如图6.13所示。 图6.13 条件约束 在实际创建中需要将Combined Fragment组件放在顺序图中，然后在其属性窗口的InteractionOperator属性中选择对应的符号即可。例如循环片段的一个实例，如图6.15所示。 图6.15 循环片段 使用顺序图对系统建模时，可以遵循如下策略： （1）设置交互语境，这些语境可以是系统、子系统、操作、类、用例和协作的一个脚本； （2）通过识别对象在交互中扮演的角色，根据对象的重要性，将其从左向右的方向放置在顺序图中。 （3）设置每个对象的生命线。一般情况下对象存在于交互的整个过程，但它可以在交互过程中创建和撤销； （4）从引发某个交互的信息开始，在生命线之间从上向下的顺序画出随后的信息； （5）设置对象的激活期，这可以可视化实际计算发生时的时间点、可视化消息嵌套等； （6）如果需要设置时间或空间约束，可以为每个消息附上合适的约束； （7）给控制流的每个消息附上前置或后置条件，这可以更详细的说明这个控制流。 根据以上策略，画顺序图的一般步骤是： （1）确定交互的范围 （2）确定参与交互过程的活动者与对象 （3）确定活动者、对象的生存周期 （4）确定交互中产生的消息 （5）细化消息的内容 "},"page/1051.html":{"url":"page/1051.html","title":"举例","keywords":"","body":"举例 【例6.1】大家比较熟悉那种能够遥控锁车、开锁、打开后备箱的钥匙。当按下“锁车”按钮的时候，汽车会自动上锁，闪动一下车灯并发出一声蜂鸣，说明车门上锁了。这里涉及到三个类：CarOwner（车主）、CarKey（车钥匙）和Car（车）。现在我们就用这样一个实例介绍顺序图的设计。 ⑴ 应用场景 该建模场景的描述如下： ①从CarOwner到CarKey的请求，要求CarKey实现getButtonPress(b)操作，登记下CarOwner按下的按钮（通常用b引用）。 ②CarKey发送消息给Car，通知Car实现其pressKeyMessage(b)操作，如果按下的按钮b是“lock”，Car就会向自己发送执行lock()操作的请求。然后，Car发送两个信号BlinkLights和Beep给CarOwner。 ⑵实现 首先，绘出３个匿名对象，它们分别是CarOwner、CarKey和Car的实例。把它们放在顺序图的最顶层，然后从每个对象绘出一条生命线，如图6.17所示。 图6.17 顺序图的初始 根据场景描述，绘制顺序图如图6.18所示。 图6.18 汽车和车钥匙顺序图 【例6.2】ATM取款看起来是个很简单的事情，从插入银行卡开始按照提示输入密码，选择“取款”，输入数额到提出现金，但是整个过程中各个对象之间要涉及到很多的消息。 【例6.3】在前面几章以图书管理系统为例进行了分析，并且已经对其静态图进行了建模。 由于图书管理员、系统管理员以及借阅者三个参与者的参与，以及对图书的操作内容较多，图书管理系统中的顺序图相对较多，比如有图书管理员处理借书顺序图、图书管理员处理还书顺序图、借阅者查询书目顺序图、系统管理员添加图书顺序图、系统管理员删除书目的顺序图、系统管理员添加借阅者账户的顺序图等。 ⑴图书管理员处理借书顺序图 图书管理员收到借阅者的借书申请时，首先验明借阅者的身份，如果没有问题，则查找借阅书目，如果借阅者没有超出最大借阅数量，则开始借阅并更新书籍列表信息，借阅成功。 图书管理员处理借书顺序图如图6.20所示。 图6.20 图书管理员处理借书顺序图 ⑵图书管理员处理还书顺序图 在图书管理系统中，图书管理员处理还书时，借阅者首先向图书管理员发出还书请求，图书管理员将读者的信息和所要还的书籍信息发送到数据库，由系统检查用户的合法性，当借阅者的信息和书籍的信息都得到确认后，工作人员修改书籍信息和借阅者信息，将结果显示处理，完成还书操作，其顺序图如图6.21所示。 图6.21 图书管理员处理还书顺序图 ⑶借阅者查询书籍顺序图 在该系统中，借阅者可以登录页面，查询书籍。其查询书籍的顺序图如图6.22所示。 ⑷系统管理员添加图书顺序图 在图书管理系统中，要添加一本新的书籍，系统管理员需要在页面上进行选择添加操作，页面会将管理员的请求发送到书目中进行搜索，该书是够为新书，如果为真则将其加入书籍列表中。具体的顺序图如图6.23所示。 图6.23 系统管理员添加图书顺序图 ⑸系统管理员删除书目的顺序图 当书籍需要报废处理时，系统管理员可以登录到后台管理，查找到对应的书目，在书籍列表中进行删除，该书目对象彻底销毁。其顺序图如图6.24所示。 图6.24 系统管理员删除书目的顺序图 在该系统中，如果有新的借阅者，则由系统管理员登录后台页面，添加借阅者信息。其顺序图如图6.25所示。 图6.25 系统管理员添加借阅者账户的顺序图 "},"page/1033.html":{"url":"page/1033.html","title":"协作图","keywords":"","body":"协作图 协作图主要用于描绘对象之间消息的移动情况来反映具体的方案，显示对象及其交互关系的空间组织结构，而非交互的顺序 "},"page/1052.html":{"url":"page/1052.html","title":"简介","keywords":"","body":"简介 顺序图按照时间顺序描述了对象间的交互，但是它过于强调交互的时间，而削弱了对象之间的静态连接关系的重视。协作图则强调了参与交互作用的对象的组织。 协作图（Collaboration Diagram）是用于描述系统的行为，是如何由系统成分协作实现的图。所谓协作是指在一定的语境中一组对象以及用以实现某些行为的这些对象间的相互作用。它描述了这样一组对象为实现某种目的而组成相互合作的“对象社会”。协作图可以表示类操作的实现。 协作图是一种交互图，强调的是发送和接收消息的对象之间的组织结构，使用协作图来说明系统的动态情况。协作图主要描述协作对象间的交互和链接，显示对象、对象间的链接以及对象间如何发送消息，它表示了协作中作为各种类元角色的对象所处的位置，在图中主要显示了类元角色和关联角色。在UML的表示中，协作图将类元角色表示为类的符号（矩形），将关联角色表现为实线的关联路径，关联路径上带有消息符号。 协作图强调参与一个交互对象的组织，它由以下基本元素组成：活动者、对象、连接和消息。 协作图的基本内容 ⑴活动者 活动者（Actor）发出主动操作的对象，负责发送初始消息，启动一个操作。 ⑵对象 对象（Object）是类的实例，负责发送和接收消息.一个协作代表了为了完成某个目标而共同工作的一组对象。对象的角色表示一个或一组对象在完成目标的过程中所应该起的作用。协作图中的对象与顺序图中的对象元素概念基本相同，表示方式也相同，只不过没有生命线，而且在协作图中，无法表示对象的创建和撤销，所以对象在协作图中的位置没有限制。 ⑶链接 链接（Link）用线条来表示链接，链接表示两个对象共享一个消息，位于对象之间或参与者与对象之间。 ⑷消息 消息（Message）的含义与顺序图中的消息基本类似。在协作图中，不带有消息的协作图标明了交互作用发生的上下文，而不表示交互。它可以用来表示单一操作的上下文，甚至可以表示一个或一组类中所有操作的上下文。如果关联线上标有消息，图形就可以表示一个交互。 图 6.26 成绩查询协作图 利用消息可以完成很多任务，可以顺序执行、添加条件限制发送、创建带有消息的对象实例和执行迭代。 ① 序列化 序列化消息只需要在消息前添加序列号，默认情况下即可。这也是最简单的方式，消息会按照要执行的顺序排序，如图6.26所示。 ② 控制点条件 控制点条件用来根据消息表达式的计算结果来限制消息的发送。控制点包含在消息中，在序列ID号和消息文本之间。 例如，如果B计算结果为真，那么ObjectA将会把消息operator1发送给ObjectB；如果C计算结果为真，那么ObjectA将会把消息operator2发送给ObjectC;其他条件下不会发送任何消息，如图6.27所示。 图6.27 控制点条件 ③ 创建实例 就像在顺序图中看到的一样，消息也可以用来在协作图中创建对象实例。为此，一个消息将会发送到新创建的对象实例。对象使用“new”构造类型，消息使用“create”构造类型，以便让读者清楚对象是在运行中创建的，如图6.28所示。 图6.28 创建实例 ④发送给多对象的消息 一个对象可能会向同一个类的多个对象同时发送一个消息。在协作图中，多对象（Multiple Object）用“一叠向后延伸的多个对象图标”表示。在多对象前面可以加上用“[]”括起来的条件，前面加一个“*”，用来说明消息发送给多个对象，如图6.29所示。 图6.29 多对象 有时，按顺序发送消息是很重要的。例如，银行出纳员（bank clerk）要按照顾客排队的次序为排名顾客（customer ）服务。可以用“while”条件表达出消息的顺序（例如“line position=l...n”) ，参见图6.30。 图6.30 一个对象以指定的次序向多对象发送消息 ⑤ 返回结果 消息可能是要求某个对象进行计算并返回结果的值。例如一个顾客对象可能请求一个计算器（calculator）对象计算某项商品的总价，包括该项商品的价格和税款。 UML提供了返回值的表示法。返回值的名字在最左，后跟赋值号“: =”，接着是操作名和操作的参数。对计算商品价格这个例子，可以表示成：totalPrice : = compute(itemPrice, salesTax）。图6.31说明了在协作图中的返回值的表示法。 表达式中赋值号的右边部分被称为消息型构（message signature)。 图6.31 一个包含返回值表示法的协作图 ⑥ 构造型 构造型（stereotype）可以在现有的UML元素的基础上创建新的元素。构造型用两对尖括号括起来的一个名称来表示，这个括号叫做双尖括号（guillemets）。这个被括起来的名称叫做关键字（keyword）。 有时侯，UML会创建新的模型。这时，UML并不是为某事物创建一个全新的符号，而是把一个关键字添加到已有的元素中。这个关键字表明了该元素的用法与其原来的意图多少有些不同。接口（interface）是一个没有属性而只有操作的类，它是使用构造型的一个例子，它是可以在整个模型中反复使用的一组行为。无须发明一个新的UML元素来表示接口，UML可以在类图标中类名的上面加一个>关键字来表示接口，如图6.32所示。 图6.32 UML2.0接口 构造型的概念在使用UML建模工具的时侯很有用。建模工具的一个重要特点是具备“字典”的功能，能够跟踪在模型中创建的所有的元素，包括类、用例、构件等等。字典只能够对已有的元素和基于这些元素的构造型有效。因此，构造型允许创建一些新的东西并把它们存储到字典中。 协作图建模技术及应用 对系统动态行为建模，当按组织对控制流建模时，一般使用协作图，与顺序图一样，一个单独的协作图只能显示一个控制流。 使用协作图建模时可以遵循如下策略： ⑴确定交互过程的上下文； ⑵确定参与交互过程的活动者与对象； ⑶如果需要，为每个对象设置初始特性； ⑷确定活动者、对象之间的链接。一般先确定关联的链接，因为这是最主要的，它代表了结构的链接。然后需要确定其他链接，用合适的路径构造型修饰，这表达了对象间是如何互相联系的。 ⑸从引发该交互过程的初始消息开始，将每个消息附到相应的链接上，可以用带小数点的编号来表达嵌套； ⑹细化消息内容。比如需要说明时间或空间的约束，可以用适当的时间或空间约束来修饰每个消息。 从面向对象的角度来看，系统的功能是由一组对象通过相互发送消息来完成的，顺序图和协作图就是通过描述这样的对象和消息来描述系统的动态行为的。协作图和顺序图作为交互图都表示出了对象间的交互作用，两者都直观地规定了发送对象和接受对象的责任，并且都支持所有的消息类型，在耦合性上两者都可以作为衡量的工具。两者在语义上是等价的，他们之间可以进行相互转换。多数的UML工具支持顺序图与协作图之间的相互转换，而不丢失任何信息。也就是只要设计出其中一种图就可以转换成另外一种图。 UML顺序图将交互关系表示为一个二维图。纵轴是一个时间轴，时间炎竖线向下延伸。横向轴代表了在协作中各个独立对象的类元角色。类元角色都具有生命线。在对象交互的表示中加入了时间维。在顺序图中，对象位于图的顶部，从上到下表示时间的流逝。每个对象都有一个垂直向下的对象生命线。消息用连接对象生命线之间的带箭头连线代表。 顺序图可供不同种类的用户使用，用户可以从顺序图中看到业务过程的细节；分析人员可以从顺序图中看到处理流程；开发人员可以看到需要开发的对象和对这些对象的操作；软件测试工程师可以看到过程的细节，并根据这个过程开发测试案例。 协作图是表达顺序图中所有信息的另一种UML 图。协作图和顺序图是语义等价的。尽管如此，这两种图在建立系统的模型时都很有用。顺序图是按照时间组织，协作图是按照对象之间的联系组织。 "},"page/1053.html":{"url":"page/1053.html","title":"举例","keywords":"","body":"举例 【例6.4】在例6.1中有一个汽车与汽车钥匙的例子，本部分以它的场景描述，绘制协作图。 首先，确定属于协作图的元素，即对象：CarKey、CarOwner、Car； 其次，建模这些元素之间的关系，着手建模早起阶段的协作图，在类元之间添加链接和关联角色。例如，CarOwner按下CarKey的按钮表示了CarOwner的请求，CarKey发送消息给Car，通知Car实现其pressKeyMessage(b)操作。 最后建模实例层的协作图，需要把类角色修改为对象实例，并且制定执行用例的消息序列。如图6.33所示。 图6.33 汽车和车钥匙协作图 【例6.5】在例6.2顺序图中有一个ATM取款的例子，本部分以它的场景描述，绘制协作图 【例6.6】在例6.3中对图书馆管理系统的顺序图进行了建模，在本部分将顺序图进行转换成对应的协作图。 ⑴图书管理员处理借书协作图 图书管理员处理借书协作图如图6.35所示，其与图6.20对应的顺序图表述相似，可以相互转换。 图6.35 图书管理员处理借书协作图 ⑵图书管理员处理还书协作图 图书管理员处理还书协作图如图6.36所示，其与图6.21对应的顺序图表述相似，可以相互转换。 图6.36 图书管理员处理还书协作图 ⑶借阅者查询书目协作图 阅者查询书目协作图如图6.37所示，其与图6.2122对应的顺序图表述相似，可以相互转换。 图6.37 借阅者查询书目协作图 ⑷系统管理员添加图书协作图 系统管理员添加图书协作图如图6.38所示，其与图6.23对应的顺序图表述相似，可以相互转换。 图6.38 系统管理员添加图书协作图 ⑸系统管理员删除书目的协作图 系统管理员删除书目的协作图如图6.39所示，其与图6.24对应的顺序图表述相似，可以相互转换。 图6.39 系统管理员删除书目的协作图 ⑹系统管理员添加借阅者账户的协作图 系统管理员添加借阅者账户的协作图如图6.40所示，其与图6.25对应的顺序图表述相似，可以相互转换。 图6.40 系统管理员添加借阅者账户的协作图 其中，消息编号用来表示一个消息的时间顺序，通过消息的顺序编号可以更清楚地看出各消息之间的时间数序，以及相互之间的关系。 "},"page/1027.html":{"url":"page/1027.html","title":"行为图","keywords":"","body":"行为图 "},"page/1028.html":{"url":"page/1028.html","title":"状态图","keywords":"","body":"状态图 描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应的。 "},"page/1046.html":{"url":"page/1046.html","title":"简介","keywords":"","body":"简介 ​ 状态图，用于UML中建立动态模型，主要描述系统随时间变化的行为，这些行为是用从静态视图中抽取的系统的瞬间值的变化来描述的。在对象的生命期建模中，状态图显示了一个状态机，展示的是单个对象内从状态到状态的控制流。状态图通过对类的对象的生存周期建立模型来描述对象随时间变化的动态行为。 UML状态图中的状态是指在对象的生命周期中满足某些条件、执行某些活动或等待某些事件时的一个条件或状况。状态用圆角矩形表示，初态（Initial States）用实心圆点表示，终态（Final States）用圆形内嵌圆点表示。状 态图（又称状态机图）由状态、转换、事件、活动和动作五部分组成，是展示状态与状态转换的图。通常一个状态图依附于一个类，并且描述一个类的实例。状态图包含了一个类的对象在其生命周期期间的所有状态的序列以及对象对接收到的事件所产生的反应。它是状态节点通过转移连接的图，描述了一个特定对象的所有可能状态，以及由于各种事件的发生而引起状态之间的转移。大多数面向对象技术都使用状态图来描述一个对象在其生命周期中的行为。 一个图书对象从它的起始点开始，首先是“新书”状态（new book），然后是“可以借阅”（available）的状态，如果有读者将书借走，则该书的状态为“已借出”状态（borrowed），如果图书被归还图书馆，图书的状态又变为“可以借阅”状态。图书馆如果放弃该图书对象的收藏，则图书对象处于“删除”状态（delete），最后到达“终止”状态。 状态图的基本元素 状态之间的过渡事件（event），对应对象的操作。事件有可能在特定的条件下发生，在UML中这样的条件称为警戒条件（guard condition）。发生事件时的处理称为动作（action）。从一个状态到另一个状态之间的连线称为转移（transitions）。状态图通常包含如下内容。 ⑴ 状态 状态定义对象在其生命周期中的条件或状况。 ⑵ 转换 对象的状态之间的转移叫转换，它包括事件和动作。 状态 一个对象的状态可能包含子状态或其它一些更加详细的内容。具体的有以下五个部分组成：名称、 进入/退出动作、 内部转换、子状态和延迟事件。 ⑴名称（name） ⑵进入/退出动作（entry/exit action） ⑶内部转换（Internal Transition） ⑷子状态（sub state） ⑸延迟事件（Deferred Event） 转换 UML状态图中转换是两个状态之间的一种关系，表示对象将在源状态（Source State）或当前状态中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态。 转换是由如下5部分组成： ⑴源状态 ⑵触发事件 ⑷动作 ⑸目标状态 在用电磁炉烧开水的过程中，水的状态由源状态“Off”（不沸腾）转换为目标状态的“On”（沸腾）时，水壶中“有水”就是其监护条件，开启电源开关“turnOn”是其触发事件，进行“烧水”是状态转换的动作。 图7.8 状态图转换的元素 状态图的建模技术及应用 状态图用于对系统的动态方面建模。动态方面是指出系统体系结构中任一对象按事件排序的行为，这些对象可以是类、接口、组件和节点。当使用状态图对系统建模时，可以在类、用例、子系统或整个系统的语境中使用状态图，对类、用例和系统实例的行为建模。 状态图表示某个类所处的不同状态和该类的状态转换信息。虽然每个类都有状态，但在系统活动期间仅对具有三个或更多潜在状态的类才画一个状态图，进行状态图描述。用状态图对一个对象按事件排序的方法建模，状态图是强调从状态到状态的控制流的状态机的简单表示。 使用状态图的最常见的是对反应型对象、尤其是对类、用例或整个系统的实例的行为建模。反应型对象是指这个对象可能处于的稳定状态、从一个状态到另一个状态之间的转换所需的触发事件，以及每个状态改变时发生的动作。反应型对象具有如下的特点： ⑴响应外部事件，即来自对象语境外的事件； ⑵具有清晰的生命期，可以被建模为状态、迁徙和事件的演化； ⑶当前行为和过去行为存在着依赖关系； ⑷在对事件做出反应后，它又变回空闲状态，等待下一个事件。 使用状态图对系统反应型对象建模时，应遵循如下策略： ⑴选择状态机的语境（即建模对象），不管它是类、用例或是整个系统； ⑵选择这个对象的初态和终态。为了指导模型的剩余部分，可能要分别地说明初态和终态的前置条件和后置条件； ⑶考虑对象可能在其中存在一段时间的条件，以决定该对象所在的稳定状态。从这个对象的高层状态开始，然后考虑它的可能的子状态； ⑷在对象的整个生命周期中，决定稳定状态的有意义的顺序； ⑸决定可能触发从状态到状态的转换的事件。将这些事件建模为触发者，它触发从一个合法状态序列到另一个合法状态序列的转换； ⑹把动作附加到这些转换上，并且附加到这些状态上； ⑺考虑通过使用子状态、分支、汇合和历史状态，来简化状态图； ⑻核实所有的状态都是在事件的某种组合下可达的； ⑼核实不存在死角状态，即不存在那种不能转换出来的状态； ⑽通过手工或通过使用工具跟踪状态机，核对所期望的事件序列以及它们的响应。 "},"page/1047.html":{"url":"page/1047.html","title":"举例","keywords":"","body":"举例 拨打电话工作的行为建模 首先，确定主要的状态，在这里电话开机时，处于空闲状态，当用户拨号呼叫某人时，话机进入拨号状态。如果呼叫成功则电话接通，电话处于通话状态，如果呼叫不成功，拨号失败，这时话机重新回到空闲状态。话机在空闲状态被呼叫，进入响铃状态。如果用户摘机接听电话，话机处于通话状态。完成通话挂机后话机回到空闲状态。如果用户没有摘机则话机处于继续响铃状态。如果用户拒绝来电，话机回到空闲状态。因此，拨打电话的过程可以总结出4个状态，即空闲、拨号、通话和响铃。 "},"page/1029.html":{"url":"page/1029.html","title":"活动图","keywords":"","body":"活动图 活动图由一些活动组成，图中同时包括了对这些活动的说明。当一个活动执行完毕之后，将沿着控制转移箭头转向下一个活动。活动图中还可以方便地描述控制转移的条件以及并行执行等要求。 "},"page/1048.html":{"url":"page/1048.html","title":"简介","keywords":"","body":"简介 ​ 活动图，用于UML中建立动态模型，主要描述系统随时间变化的行为，这些行为是用从静态视图中抽取的系统的瞬间值的变化来描述的。在对象的生命期建模中，活动图是一种特殊形式的状态机，用于对计算机流程和工作流程建模。活动图从本质上说是一个流程图，展现跨过不同的对象从活动到活动的控制流。与传统的流程图不同的是，活动图能够展示并发和控制分支。 在用例模型中，可以利用文本来描述用例的业务流程，但如果业务流程较为复杂的话，则可能会难以阅读和理解，这时需要用更加容易理解的方式（图形）来描述业务过程的工作流，在UML中将这类描述活动流程的图形称为活动图（Activity Diagram）。 活动图被设计用于简化描述一个过程或者操作的工作步骤。活动用圆角矩形表示，接近椭圆。一个活动中的处理一旦完成，则自动引起下一个活动的发生。箭头表示从一个活动转移到下一个活动。和状态图类似，活动图中的起点用一个实心圆表示，终点用一个实心圆外加一个圆圈表示。在一个活动图中，只有一个起始状态，可以有零个或多个终止状态。 活动图表示在处理某个活动时，两个或者更多类对象之间的过程控制流。它用来描述采取何种动作、做什么（对象状态改变）、何时发生（动作序列）以及何处发生（泳道）。活动图可用于在业务单元的级别上对更高级别的业务过程进行建模，或者对低级别的内部类操作进行建模。活动图可以用作以下目的： ⑴描述一个操作执行过程中所完成的工作（动作），这是活动图最常见的用途。 ⑵描述对象内部的工作。 ⑶显示如何执行一组相关的动作，以及这些动作如何影响它们周围的对象。 ⑷显示用例的实例如何执行动作以及如何改变对象状态。 ⑸说明一次业务流程中的人（参与者）和对象是如何工作的。 活动图说明了起点、终点、两个活动和转移的表示法。 活动图的基本元素 活动图的符号集与状态图中使用的符号集类似。像状态图一样，活动图也从一个连接到初始活动的实心圆开始。活动是通过一个圆角矩形（活动的名称包含在其内）来表示的。活动可以通过转换线段连接到其他活动，或者连接到判断点，这些判断点连接到由判断点的条件所保护的不同活动。结束过程的活动连接到一个终止点（就像在状态图中一样）。活动图中的基本要素包括状态、转移、分支、分叉和汇合、泳道、对象流等。 动作状态 对象的动作状态是活动图中最小单位的构造块，表示原子动作。动作状态有三个特性： ⑴原子性：即不能被分解成更小的部分； ⑵不可中断性：即一旦开始就必须运行到结束； ⑶瞬时性：即动作状态所占用的处理时间通常是极短的，甚至是可以被忽略的动作状态使用带圆端的方框表示。如图7.13符号所示。 动作状态如图示 活动状态 动作状态表示的是不可分割的原子动作，而活动状态则不同，它表示的是可以分割的动作。特点是：它可以被分解成其他子活动或动作状态，它能够被中断，占有有限的时间。活动状态可以理解为一个组合，它的控制流由其他活动状态或动作状态组成。 在UML中，动作状态和活动状态的图标没有什么区别，都是圆端的方框。只是活动状态可以有附加的部分，如可以指定入口动作、出口动作、动作状态以及内嵌状态机。 转移 转移也称转换是两个状态间的一种关系，表示对象将在当前状态中执行动作，并在某个特定事件发生或某个特定的条件满足时进入后继状态。在UML中用一条简单的带箭头的直线表示一个转移。箭头上可以带有监护条件表达式。 分支 分支用于描述基于某个条件的可选择路径。一个分支可以有一个进入转移和两个或多个输出转移。在每条输出转移上都有监护条件表达式保护，当且仅当监护条件表达式为真时，该输出路径才有效。在所有输出转移中，其监护条件不能重叠，而且它们应该覆盖所有的可能性。UML活动图中的分支用菱形表示。 分叉和汇合 对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。 在UML中使用分叉和汇合表示并行发生的事件流。分叉表示把一个单独的控制流分成两个或多个并发的控制流。一个分叉可以有一个进入转移和两个或多个输出转移，每一个转移表示一个独立的控制流。 汇合表示两个或多个并发控制流的同步发生，一个汇合可以有两个或多个进入转移和一个输出转移。分叉和汇合应该是平衡的。分叉和汇合在图形上都使用同步条来表示，同步条通常用一条粗的水平线表示。 显示了分叉和汇合的图示 泳道 泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。每一组表示一个特定的类、人或部门，他们负责完成组内的活动。在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。泳道用于表示实际执行活动的对象。 泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。 对象流 用活动图描述某个对象时，可以把所涉及的对象放置在活动图上，并用一个依赖将这些对象连接到对它们进行创建、撤销和修改的活动转移上。这种包括依赖关系和对象的应用被称为对象流。对象流是动作和对象间的关联。对象流可用于对下列关系建模：动作状态对对象的使用以及动作状态对对象的影响。 对象流中的对象有以下特点： ⑴一个对象可以由多个动作操作。 ⑵一个动作输出的对象可以作为另一个动作输入的对象。 ⑶在活动图中，同一个对象可以多次出现，它的每一次出现表明该对象正处于对象生存期的不同时间点。 对象流用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。状态图中的对象用矩形表示，矩形内是该对象的名称，名称下的方括号表明对象此时的状态。 下图显示了一个支付账单的对象流。 活动图的建模技术及应用 活动图用于对系统的动态行为建模，在对一个系统建模时，通常有两种使用活动图的方式： ⑴为工作流建模 对工作流建模强调与系统进行交互的对象所观察到的活动。工作流一般处于系统的边界，用于可视化、详述、构造和文档化开发系统所涉及的业务流程。用于业务建模的时候，每一条泳道表示一个职责单位，该图能够有效地体现出所有职责单位之间的工作职责，业务范围及之间的交互关系、信息流程。 ⑵为对象的操作建模 在这种情况下活动图本质上就是流程图，它描述系统的活动、判定点和分支等部分。因此，在UML中，可以把活动图作为流程图来使用，用于对系统的操作建模。每一个对象占据一个泳道，而活动则是该对象的成员方法。 状态图和活动图都是用于对系统的动态行为建模。状态机是展示状态与状态转换的图。通常一个状态机依附于一个类，并且描述这个类实例对接收到的事物的反应。状态机有两种可视化方式，分别是状态图和活动图。如果强调对象的潜在状态和这些状态的间的转换，一般使用状态图；如果强调从活动到活动的控制流，一般使用活动图。活动图被设计用于描述一个过程或操作的工作步骤，从这方面讲，它可以算是状态的一种扩展方式，状态图描述一个对象的状态以及状态的改变，而活动图除了描述对象状态外，更突出了它的活动。 本章介绍了状态图和活动图的基本概念、UML表示法和建模的技术。在UML建模过程中，状态图是非常必要的，它能帮助系统开发人员理解系统中对象的行为。而类和对象图只能展现系统的静态层次和关联，并不能表达系统的行为。而详细描述了对象行为的状态图，帮助开发人员构造出符合用户需求的系统。通过拨打电话工作、航班机票预订系统和网上银行登录系统来阐述了状态图的绘制过程：确定状态，分析状态间的转换，细化活动与内部转化等过程完成状态，介绍了状态图对对象的生命周期建模以及对反应型对象的行为建模的功能和建模策略。 UML中的活动图主要是个流图，它描述了从活动到活动的控制流，它还可以过来描述对象在控制流的不同点从一个状态转移到另外一个状态的对象流。对活动图的基本内容的讲解，主要包括动作状态、活动状态、转移、分支、分叉和汇合、泳道、对象流。并举例探讨了用活动图为工作流建模和操作建模的策略。 "},"page/1049.html":{"url":"page/1049.html","title":"举例","keywords":"","body":"举例 "},"page/1034.html":{"url":"page/1034.html","title":"实现图","keywords":"","body":"实现图 "},"page/1035.html":{"url":"page/1035.html","title":"组件图","keywords":"","body":"组件图 组件图，也称为构件图。组件图描述代码部件的物理结构及各部件之间的依赖关系，组件图有助于分析和理解部件之间的相互影响程度。 "},"page/1054.html":{"url":"page/1054.html","title":"简介","keywords":"","body":"简介 ​ 组件图是面向对象系统的物理方面建模时使用的图，是表示组件类型的组织以及各种组件之间依赖关系的图。组件图通过对组件间依赖关系的描述来估计对系统组件的修改给系统可能带来的影响。组件图用于描述系统中软件的构成，但没有描述系统中与硬件有关的构成情况。 组件图是对面向对象系统的物理方面建模时使用的两种图之一（另一种图是部署图），用于描述软件组件以及组件之间的组织和依赖关系。软件组件是软件系统的一个物理单元。作为一个或多个类的软件实现，组件驻留在计算机中。组件提供和其他组件之间的接口。在UML 1.x 中，数据文件、表格、可执行文件、文档和动态链接库等都被定义为组件。实际上，建模者习惯把这些东西划分为部署组件（deployment component）、工作产品组件（work product component）和执行组件（execution component）。UML 2.0 则统称它们为工件（artifact） , 也就是系统使用或产生的一段信息。组件定义了一个系统的功能。就好像一个组件是一个或多个类的实现一样，工件（如果它是可执行的话）是一个组件的实现。组件图有利于： ⑴帮助客户理解最终的系统结构。 ⑵使开发工作有一个明确的目标。 ⑶帮助开发组的其他人员理解系统。 ⑷复用软件组件。 组件（Component） 1. 组件的基本概念和图形表示 组件是系统中遵从一组接口且提供实现的一个物理部件，通常指开发和运行时类的物理实现。组件常用于对可分配的物理单元建模，这些物理单元包含模型元素，并具有身份标识和明确定义的接口，它具有很广泛的定义，以下的一些内容都可以被认为是组件：程序源代码、子系统、动态链接库等。组件的图形表示法是把组件画成带有两个标签的矩形。每一个组件都必须有一个唯一的名称（name）。 组件图的主图标是一个左侧附有两个小矩形的大矩形框。组件的名字位于组件图标的中央，名字本身是一个文本字符串。如图所示。 2. 组件的类型 组件可以分为以下三种类型: （1）实施组件（Deployment Component）:实施组件是构成一个可执行系统必要和充分的组件，如动态链接库（DLL）、二进制可执行体（EXE）、ActiveX控件和JavaBean组件等 （2）工作产品组件（Work Product Component）:这类组件主要是开发过程的产物，包括创建实施组件的源代码文件及数据文件，这些组件并不是直接地参加可执行系统，而开发过程中的工作产品，用于产生可执行系统。 （3）执行组件（Execution Component）:这类组件是作为一个正在执行的系统的结果而被创建的，如由DLL实例化形成的COM＋对象。 3. 组件与类的异同 一般来说组件在许多方面都与类相同：二者都有名称；都可以实现一组接口；都可以参与依赖、泛化和关联关系；都可以被嵌套；都可以有实例；都可以参与交互。但是组件和类之间也有一些显著的差别： （1）类表示逻辑抽象，而组件表示存在于计算机中的物理抽象。简言之，组件是可以存在于可实际的运行的计算机上的，而类不可以。 （2）组件表示的是物理模块而不是逻辑模块，与类处于不同的抽象级别。组件是一组其他逻辑元素的物理实现（如类及其协作关系），而类仅仅只是逻辑上的概念。 （3）类可以直接拥有属性和操作；而一般情况下，组件仅拥有只能通过其接口访问的操作。这表明虽然组件和类都可以实现一个接口，但是组件的服务一般只能通过其接口来访问。 接口（Interface） 接口是一组用于描述类或组件的一个服务的操作，它是一个被命名的操作的集合，与类不同，它不描述任何结构（因此不包含任何属性），也不描述任何实现（因此不包括任何实现操作的方法）。每个接口都有一个唯一的名称。 组件的接口可以分为两种类型。 （1）导出接口（expert interface）：即为其他组件提供服务的接口，一个组件可以有多个导出接口。 （2）导入接口（import interface）：在组件中所用到的其他组件所提供的接口，称为导入接口，一个组件可以使用多个导入接口。 关系（relationship） 关系是事物之间的联系，在面向对象的建模中，最重要的关系是依赖、泛化、关联和实现，但组件图中使用最多的是依赖和实现关系。 依赖关系是指组件依赖外部提供的服务（由组件到接口）。组件图中的依赖关系使用虚线箭头表示。如图(右)所示。 实现关系是指组件向外提供的服务。实现关系使用实线表示。实现关系多用于组件和接口之间。组件可以实现接口。如图（左）所示。 使用组件图对系统建模及应用 1. 组件图建模及绘图的步骤 使用组件图建模的步骤可按照下列步骤进行： 对系统中的组件建模； 定义相关组件提供的接口； 对它们间的关系建模； 对建模的结果进行精化和细化。 "},"page/1055.html":{"url":"page/1055.html","title":"举例","keywords":"","body":"举例 "},"page/1036.html":{"url":"page/1036.html","title":"部署图","keywords":"","body":"部署图 部署图，也称为配置图。UML面向对象中配置图描述系统中硬件和软件的物理配置情况和系统体系结构。 "},"page/1056.html":{"url":"page/1056.html","title":"简介","keywords":"","body":"简介 ​ 部署图是面向对象系统的物理方面建模时使用的图，用于描述系统硬件的物理拓扑结构以及在此结构上运行的软件。部署图可以显示计算节点的拓扑结构、通信路径、节点上运行的软件、软件包含的逻辑单元（对象、类等）。部署图是描述任何基于计算机的应用系统（特别是基于Internet和Web的分布式计算系统）的物理配置的有力工具。 部署图（deployment diagram） 它用于静态建模，是表示运行时过程节点（node）结构、组件实例及其对象结构的图。展示了第9章组件图中所提到的组件如何在系统硬件上部署，以及各个硬件部件如何相互连接。UML部署图显示了基于计算机系统的物理体系结构。它可以描述计算机，展示它们之间的连接，以及驻留在每台机器中的软件。每台计算机用一个立方体来表示，立方体之间的连线表示这些计算机之间的通信关系。 部署图可以显示计算节点的拓扑结构、通信路径、节点上运行的软件、软件包含的逻辑单元（对象、类等）。部署图是描述任何基于计算机的应用系统（特别是基于Internet和Web的分布式计算系统）的物理配置的有力工具。 构成部署图的元素主要是节点（node）、组件（component）和关系（relationship）。 节点是存在于运行时并代表一项计算资源的物理元素，一般至少拥有一些内存，而且通常具有处理能力。它一般用于对执行处理或计算的资源建模，通常具有如下两方面内容：能力（如基本内存、计算能力和二级存储器）和位置（在所有必需的地方均可得到）。在建模过程中，可以把节点分成两种类型： 在UML1.x中，节点被划分为两种类型：处理器（processor）和设备（device）。处理器（Processor）是能够执行软件组件、具有计算能力的节点。设备（Device）是不能执行软件组件的外围硬件，没有计算能力的节点，通常是通过其接口为外界提供某种服务，例如打印机、扫描仪等都是设备。尽管这种区分并没有在UML1.x 中形式化，但是它很有用。 在UML2.0中用立方体来表示一个节点（与UML1.x 例图一样）。UML2.0正式地把一个设备定义为一个执行工件（artifact）的节点。为节点起一个名字，并添加关键字>来指明节点类型，尽管一般不需要这样做。 组件（Component） 部署图中还可以包含组件，这里所指的组件组件图中的基本元素，它是系统可替换的物理部件。 节点和组件的关系可以归纳为以下两点： ⑴组件是参与系统执行的事物，而节点是执行组件的事物。简单的说就是组件是被节点执行的事物，如假设节点是一台服务器，则组件就是其上运行的软件。 ⑵组件表示逻辑元素的物理模块，而节点表示组件的物理部署。这表明一个组件是逻辑单元（如类）的物理实现，而一个节点则是组件被部署的地点。一个类可以被一个或多个组件实现，而一个组件也可以部署在一个或多个节点上。 关系（relationship） 部署图中也可以包括依赖、泛化、关联及实现关系。 部署图中的依赖关系使用虚线箭头表示。它通常用在部署图中的组件和组件之间，组件依赖外部提供的服务（由组件到接口）。下图（左）示意了依赖关系。 实现关系是节点内组件向外提供服务，其表示符号是一条实线。关联关系是体现节点间通信关联，其表示符号也是一条实线。 下图（右）示意 部署图的系统建模及应用 部署图用于对系统的静态部署视图建模。这种视图主要用来解决构成物理系统的各组成部分的分布、提交和安装。有些开发的系统不需要部署图，比如开发的软件是将运行在一台机器上而且只和该机器上已由宿主操作系统管理的标准设备（如键盘）相互作用，就不必要设计部署图。如果软件交互设备是物理地分布在多个处理器上的，则使用部署图有助于思考系统中软件到硬件的映射。 组件图用于静态建模，是表示组件类型的组织以及各种组件之间依赖关系的图。组件图通过对组件间依赖关系的描述来估计对系统组件的修改给系统可能带来的影响。部署图是用来为面向对象系统的物理实现建模的图。部署图描述了节点和运行在其上的组件的配置，它用来模拟系统的静态部署实现。 本章介绍了组件的定义以构成组件的要素，对组件、组件关系进行了详细的讲解。对使用组件图建模适用领域进行了说明，并对最为常见的两种场景即可执行程序结构建模、源代码建模进行了举例说明。还介绍了部署图语义和功能，通过实例讲解了部署图的应用。 "},"page/1057.html":{"url":"page/1057.html","title":"举例","keywords":"","body":"举例 "},"page/1058.html":{"url":"page/1058.html","title":"规则2/3","keywords":"","body":"规则 不能简单地把 UML 的构造块按随机的方式堆放在一起。像任何语言一样，UML 有一套规则，这些规则描述了一个形式良好的模型应该是什么样。形式良好的模型应该在语义上是自我一致的，并且与所有的相关模型协调一致。 UML有自己的语法和语义规则，用于： 命名——为事物、关系和图起的名字； 范围——使名字具有特定含义的语境； 可见性——这些名字如何让其他成分看见和使用； 完整性——事物如何正确、一致地相互联系； 执行——运行或模拟一个动态模型意味着什么。 在软件密集型系统的开发期间所建造的模型往往需要发展变化，并可以由许多人员以不同的方式、在不同的时间进行观察。由于这个原因，下述的情况是常见的，即开发组不但会建造一些形式良好的模型，也会建造一些像下面这样的模型： 省略——隐藏某些元素以简化视图； 不完全——可能遗漏了某些元素； 不一致——模型的完整性得不到保证。 在软件开发的生命期内，随着系统细节的展开和变动，不可避免地要出现这样一些不太规范的模型。UML 的规则鼓励（不是强迫）专注于最重要的分析、设计和实现问题，这将促使模型随着时间的推移而具有良好的结构。 "},"page/1059.html":{"url":"page/1059.html","title":"公共机制3/3","keywords":"","body":"公共机制 通过与具有公共特征的模式取得一致，可以使一座建筑更为简单和更为协调。房子可以按一定的结构模式（它定义了建筑风格）建造成维多利亚式的或法国乡村式的。对于UML也是如此。由于在UML中有4种贯穿整个语言且一致应用的公共机制，因此使得UML变得较为简单。这4种机制是： （1）规约； （2）修饰； （3）通用划分； （4）扩展机制。 1.规约 UML 不仅仅是一种图形语言。实际上，在它的图形表示法的每部分背后都有一个规约，这个规约提供了对构造块的语法和语义的文字叙述。例如，在类的图符背后有一个规约，它提供了对该类所拥有的属性、操作（包括完整的特征标记）和行为的全面描述；在视觉上，类的图符可能仅展示了这个规约的一小部分。此外，可能存在着该类的另一个视图，其中提供了一个完全不同的部件集合，但是它仍然与该类的基本规约相一致。UML 的图形表示法用来对系统进行可视化；UML 的规约用来说明系统的细节。假定把二者分开，就可能进行增量式的建模。这可以通过以下方式完成：先画图，然后再对这个模型的规约增加语义，或直接创建规约，也可能对一个已经存在的系统进行逆向工程，然后再创建作为这些规约的投影的图。 UML 的规约提供了一个语义底版，它包含了一个系统的各个模型的所有部分，各部分以一致的方式相互联系。因此，UML 的图只不过是对底版的简单视觉投影，每一个图展现了系统的一个特定的关注方面。 2.修饰 UML中的大多数元素都有唯一而直接的图形表示符号，这些图形符号对元素的最重要的方面提供了可视化表示。例如，特意把类的符号设计得容易画出，这是因为在面向对象系统建模中，类是最常用的元素；类的图形符号展示了类的最重要方面，即它的名称、属性和操作。 对类的规约可以包含其他细节，例如，它是否为抽象类，或它的属性和操作是否可见。可以把很多这样的细节表示为图形或文字修饰，放到类的基本矩形符号上。例如，下图表示的是一个带有修饰的类，图中表明这个类是一个抽象类，有两个公共操作、一个受保护操作和一个私有操作。 修饰 UML表示法中的每一个元素都有一个基本符号，可以把各种修饰细节加到这个符号上。 3.通用划分 在对面向对象系统建模中，通常有几种划分方式。 第一种方式是对类和对象的划分。类是一种抽象，对象是这种抽象的一个具体表现。在UML中，可以对类和对象建立模型，如下图所示。在图形上，UML是这样区分对象的：采用与类同样的图形符号来表示对象，并且在对象名的下面画一道线。 类和对象 在这个图中，有一个名称为Customer的类，它有3个对象，分别为Jan（它被明确地标记为Customer的对象），:Customer（匿名的Customer对象）和Elyse（它在规约中被说明为一种Customer对象，尽管在这里没有明确地表示出来）。 UML的每一个构造块几乎都存在像类/对象这样的二分法。例如，可以有用况和用况执行、构件和构件实例、结点和结点实例等。 第二种方式是接口和实现的分离。接口声明了一个合约，而实现则表示了对该合约的具体实施，它负责如实地实现接口的完整语义。在UML中，既可以对接口建模又可以对它们的实现建模，如图所示。 接口和实现 在这个图中，有一个名称为SpellingWizard.dll的构件，它实现了接口IUnknown和接口ISpelling，并且还需要一个由其他构件提供的名为IDictionary的接口。 几乎每一个UML的构造块都有像接口/实现这样的二分法。例如，用况和实现它们的协作，操作和实现它们的方法。 第三种方式是类型和角色的分离。类型声明了实体的种类（如对象、属性或参数），角色描述了实体在语境中的含义（如类、构件或协作等）。任何作为其他实体结构中的一部分的实体（例如属性）都具有两个特性：从它固有的类型派生出一些含义，从它在语境中的角色派生出一些含义（如图所示）。 具有角色和类型的部件 4.扩展机制 UML 提供了一种绘制软件蓝图的标准语言，但是一种闭合的语言即使表达能力再丰富，也难以表示出各种领域中的各种模型在不同时刻所有可能的细微差别。由于这个原因，UML 是目标开放的，使人们能够以受控的方式来扩展该语言。UML的扩展机制包括： 衍型； 标记值； 约束。 衍型 （stereotype）扩展了UML的词汇，可以用来创造新的构造块，这个新构造块既是从现有的构造块派生的，但是针对专门的问题。例如，假设正在使用一种编程语言，如Java或C++，经常要对“异常事件”建模。在这些语言里，“异常事件”就是类，只是用很特殊的方法进行了处理。通常可能只想允许抛出和捕捉异常事件，没有其他要求。此时可以让异常事件在模型中成为“一等公民”——可以像对待基本构造块一样对待它们，只要用一个适当的衍型来标记它们即可。请看图中的类Overflow。 扩展机制 标记值 （tagged value）扩展了UML衍型的特性，可以用来创建衍型规约的新信息。例如，如果在制作以盒装形式销售的产品，随着时间的推移，它经过了多次发行，那么经常会想要跟踪产品的版本和对产品做关键摘要的作者。版本和作者不是UML的基本概念，通过引入新的标记值，可以把它们加到像类那样的任何构造块中去。例如，在上图中，在类EventQueue上明确标记了版本和作者，这样就对该类进行了扩展。 约束 （constraint）扩展了UML构造块的语义，可以用来增加新的规则或修改现有的规则。例如，可能想约束类 EventQueue，以使所有的增加都按序排列。如上图所示，对操作 add增加了一个约束，即{ordered}，以明确标示这一规则。 总的来说，这3种扩展机制允许根据项目的需要来塑造和培育UML。这些机制也使得UML适合于新的软件技术（例如，很可能出现的功能更强的分布式编程语言）。可以增加新的构造块，修改已存在的构造块的规约，甚至可以改变它们的语义。当然，以受控的方式进行扩展是重要的，这样可以不偏离UML的目标——信息交流。 "},"page/1060.html":{"url":"page/1060.html","title":"体系结构","keywords":"","body":"体系结构 可视化、详述、构造和文档化一个软件密集型系统，要求从几个角度去观察系统。各种人员——最终用户、分析人员、开发人员、系统集成人员、测试人员、技术资料作者和项目管理者——各自带着项目的不同日程，在项目的生命周期内各自在不同的时间、以不同的方式来看系统。系统体系结构或许是最重要的制品，它可以驾驭不同的视点，并在整个项目的生命周期内控制对系统的迭代和增量式开发。 体系结构是一组有关下述内容的重要决策： 软件系统的组织； 对组成系统的结构元素及其接口的选择； 像元素间的协作所描述的那样的行为； 将这些结构元素和行为元素组合到逐步增大的子系统中； 指导这种组织的体系结构风格：静态和动态元素以及它们的接口、协作和组成。 软件体系结构不仅关心结构和行为，而且还关心用法、功能、性能、弹性、复用、可理解性、经济与技术约束及其折中，以及审美的考虑。 如图所示，最好用5个互连的视图来描述软件密集型系统的体系结构。每一个视图是在一个特定的方面对系统的组织和结构进行的投影。这5种视图中的每一种都可单独使用，使不同的人员能专注于他们最为关心的体系结构问题。这5种视图也会相互作用，如部署视图中的结点拥有实现视图的构件，而这些构件又表示了设计视图和交互视图中的类、接口、协作以及主动类的物理实现。UML允许表达这5种视图中的任何一种。 对系统的体系结构建模 1、用例（况）视图 用例视图主要描述一个系统应该具备的功能，指的是从系统的外部参与者所能看到的系统功能。用例表示的是系统的一个功能单元，可以被描述为参与者与系统之间的一次交互作用。 用例模型的用途主要是列举出系统中的用例和参与者，并指出哪个参与者参与了哪个用例的执行。用例视图是其他4种视图的核心，它的内容直接驱动其他视图的开发。 系统的用况视图 （use case view）由描述可被最终用户、分析人员和测试人员看到的系统行为的用况组成。用况视图实际上没有描述软件系统的组织，而是描述了形成系统体系结构的动力。在UML中，该视图的静态方面由用况图表现；动态方面由交互图、状态图和活动图表现。 2、实现（逻辑）视图 系统的实现视图 （implementation view）包含了用于装配与发布物理系统的制品。这种视图主要针对系统发布的配置管理，它由一些独立的文件组成；这些文件可以用各种方法装配，以产生运行系统。它也关注从逻辑的类和构件到物理制品的映射。在UML中，该视图的静态方面由构件图表现，动态方面由交互图、状态图和活动图表现。 逻辑视图主要用于描述在用例视图中提出的系统功能的实现。逻辑视图主要关注系统的内部，它既描述系统的静态结构（系统中的类、对象以及他们之间的关系），也描述系统的动态协作关系。 逻辑视图的使用者主要是系统的设计人员和开发人员。 3、交互（并发）视图 系统的交互视图 （interaction view）展示了系统的不同部分之间的控制流，包括可能的并发和同步机制。该视图主要针对性能、可伸缩性和系统的吞吐量。在UML中，对该视图的静态方面和动态方面的表现与设计视图相同，但着重于控制系统的主动类和在它们之间流动的消息。 并发视图主要是从资源的有效利用、代码的并行执行以及系统环境中异步事件的处理等方面的考虑。将系统划分为并发执行的控制。 并发视图的使用者是开发人员和系统集成人员。 4、设计（组件）视图 系统的设计视图 （design view）包含了类、接口和协作，它们形成了问题及其解决方案的词汇。这种视图主要支持系统的功能需求，即系统应该提供给最终用户的服务。在UML中，该视图的静态方面由类图和对象图表现；动态方面由交互图、状态图和活动图表现。类的内部结构图特别有用。 组件视图描述系统的实现模块以及它们之间的依赖关系。其中，组件指的是不同类型的代码模块，它是构造应用的软件单元。组件视图中也可以添加组件的其他附加信息，例如，资源分配或者其他管理信息。 组件视图主要由组件图构成。组件视图的使用者是开发人员。 5、部署视图 系统的部署视图 （deployment view）包含了形成系统硬件拓扑结构的结点（系统在其上运行）。这种视图主要描述组成物理系统的部件的分布、交付和安装。在UML中，该视图的静态方面由部署图表现，动态方面由交互图、状态图和活动图表现。 部署视图，也称之为配置视图。配置视图主要显示系统的物理部署，它描述位于节点上的运行实例的部署情况。配置视图主要由配置图表示，配置视图还允许评估分配结果和资源分配。 配置视图的使用者是开发人员、系统集成人员和测试人员。 "},"page/1018.html":{"url":"page/1018.html","title":"888","keywords":"","body":""},"page/1999.html":{"url":"page/1999.html","title":"end1061","keywords":"","body":"end1060 "}}