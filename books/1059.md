# 公共机制

通过与具有公共特征的模式取得一致，可以使一座建筑更为简单和更为协调。房子可以按一定的结构模式（它定义了建筑风格）建造成维多利亚式的或法国乡村式的。对于UML也是如此。由于在UML中有4种贯穿整个语言且一致应用的公共机制，因此使得UML变得较为简单。这4种机制是：

（1）规约；

（2）修饰；

（3）通用划分；

（4）扩展机制。

## 1.规约

UML 不仅仅是一种图形语言。实际上，在它的图形表示法的每部分背后都有一个规约，这个规约提供了对构造块的语法和语义的文字叙述。例如，在类的图符背后有一个规约，它提供了对该类所拥有的属性、操作（包括完整的特征标记）和行为的全面描述；在视觉上，类的图符可能仅展示了这个规约的一小部分。此外，可能存在着该类的另一个视图，其中提供了一个完全不同的部件集合，但是它仍然与该类的基本规约相一致。UML 的图形表示法用来对系统进行可视化；UML 的规约用来说明系统的细节。假定把二者分开，就可能进行增量式的建模。这可以通过以下方式完成：先画图，然后再对这个模型的规约增加语义，或直接创建规约，也可能对一个已经存在的系统进行逆向工程，然后再创建作为这些规约的投影的图。

UML 的规约提供了一个语义底版，它包含了一个系统的各个模型的所有部分，各部分以一致的方式相互联系。因此，UML 的图只不过是对底版的简单视觉投影，每一个图展现了系统的一个特定的关注方面。

## 2.修饰

UML中的大多数元素都有唯一而直接的图形表示符号，这些图形符号对元素的最重要的方面提供了可视化表示。例如，特意把类的符号设计得容易画出，这是因为在面向对象系统建模中，类是最常用的元素；类的图形符号展示了类的最重要方面，即它的名称、属性和操作。



对类的规约可以包含其他细节，例如，它是否为抽象类，或它的属性和操作是否可见。可以把很多这样的细节表示为图形或文字修饰，放到类的基本矩形符号上。例如，下图表示的是一个带有修饰的类，图中表明这个类是一个抽象类，有两个公共操作、一个受保护操作和一个私有操作。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191217115240.png)

<center>修饰</center>

UML表示法中的每一个元素都有一个基本符号，可以把各种修饰细节加到这个符号上。

## 3.通用划分

在对面向对象系统建模中，通常有几种划分方式。

第一种方式是对类和对象的划分。类是一种抽象，对象是这种抽象的一个具体表现。在UML中，可以对类和对象建立模型，如下图所示。在图形上，UML是这样区分对象的：采用与类同样的图形符号来表示对象，并且在对象名的下面画一道线。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191217120059.png)

<center>类和对象</center>

 在这个图中，有一个名称为Customer的类，它有3个对象，分别为Jan（它被明确地标记为Customer的对象），:Customer（匿名的Customer对象）和Elyse（它在规约中被说明为一种Customer对象，尽管在这里没有明确地表示出来）。

UML的每一个构造块几乎都存在像类/对象这样的二分法。例如，可以有用况和用况执行、构件和构件实例、结点和结点实例等。

第二种方式是接口和实现的分离。接口声明了一个合约，而实现则表示了对该合约的具体实施，它负责如实地实现接口的完整语义。在UML中，既可以对接口建模又可以对它们的实现建模，如图所示。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191217120651.png)





<center>接口和实现</center>

在这个图中，有一个名称为SpellingWizard.dll的构件，它实现了接口IUnknown和接口ISpelling，并且还需要一个由其他构件提供的名为IDictionary的接口。

几乎每一个UML的构造块都有像接口/实现这样的二分法。例如，用况和实现它们的协作，操作和实现它们的方法。

第三种方式是类型和角色的分离。类型声明了实体的种类（如对象、属性或参数），角色描述了实体在语境中的含义（如类、构件或协作等）。任何作为其他实体结构中的一部分的实体（例如属性）都具有两个特性：从它固有的类型派生出一些含义，从它在语境中的角色派生出一些含义（如图所示）。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191217121010.png)





<center>具有角色和类型的部件</center>



## 4.扩展机制

UML 提供了一种绘制软件蓝图的标准语言，但是一种闭合的语言即使表达能力再丰富，也难以表示出各种领域中的各种模型在不同时刻所有可能的细微差别。由于这个原因，UML 是目标开放的，使人们能够以受控的方式来扩展该语言。UML的扩展机制包括：

衍型；

标记值；

约束。

衍型 （stereotype）扩展了UML的词汇，可以用来创造新的构造块，这个新构造块既是从现有的构造块派生的，但是针对专门的问题。例如，假设正在使用一种编程语言，如Java或C++，经常要对“异常事件”建模。在这些语言里，“异常事件”就是类，只是用很特殊的方法进行了处理。通常可能只想允许抛出和捕捉异常事件，没有其他要求。此时可以让异常事件在模型中成为“一等公民”——可以像对待基本构造块一样对待它们，只要用一个适当的衍型来标记它们即可。请看图中的类Overflow。



![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191217121646.png)



<center>扩展机制</center>

 

标记值 （tagged value）扩展了UML衍型的特性，可以用来创建衍型规约的新信息。例如，如果在制作以盒装形式销售的产品，随着时间的推移，它经过了多次发行，那么经常会想要跟踪产品的版本和对产品做关键摘要的作者。版本和作者不是UML的基本概念，通过引入新的标记值，可以把它们加到像类那样的任何构造块中去。例如，在上图中，在类EventQueue上明确标记了版本和作者，这样就对该类进行了扩展。

约束 （constraint）扩展了UML构造块的语义，可以用来增加新的规则或修改现有的规则。例如，可能想约束类 EventQueue，以使所有的增加都按序排列。如上图所示，对操作 add增加了一个约束，即{ordered}，以明确标示这一规则。

总的来说，这3种扩展机制允许根据项目的需要来塑造和培育UML。这些机制也使得UML适合于新的软件技术（例如，很可能出现的功能更强的分布式编程语言）。可以增加新的构造块，修改已存在的构造块的规约，甚至可以改变它们的语义。当然，以受控的方式进行扩展是重要的，这样可以不偏离UML的目标——信息交流。

